#!/bin/sh
#
### BEGIN INIT INFO
# Provides:          opsiconfd
# Required-Start:    $network $local_fs
# Required-Stop:     $network $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: opsi config service
# Description:       Opsi Configuration Service
### END INIT INFO

DAEMON=/usr/sbin/opsiconfd
# This user must have read access to /etc/shadow
USER=opsiconfd
LOGDIR=/var/log/opsi/opsiconfd
PIDDIR=/var/run/opsiconfd
PIDFILE=$PIDDIR/opsiconfd.pid
START_GUARD=1
GUARD_BIN=/usr/sbin/opsiconfd-guard
FQDN=`hostname -f`

# See if the binary is there
if [ ! -x $DAEMON ]; then
	echo "$DAEMON not installed"
	[ "$1" = "stop" ] && exit 0
	exit 5
fi

case "$1" in
	start)
		echo -n "Starting opsi config service.."
		
		# Kill opsiconfd-guard
		killall `basename $GUARD_BIN` 1>/dev/null 2>/dev/null
		
		# Make sure we have our PIDDIR, even if it's on a tmpfs
		install -o $USER -g root -m 755 -d $PIDDIR
		
		# Make sure logfiles are writable
		test ! -e $LOGDIR && mkdir -p $LOGDIR
		chown -R $USER $LOGDIR
		
		if [ -f $PIDFILE ] && ps h `cat $PIDFILE` > /dev/null; then
			echo ".   (already running)."
			[ "$START_GUARD" = "1" ] && $GUARD_BIN &
			exit 0
		else
			# Copy server cert / key if running on ucs
			if [ -e "/etc/univention/ssl/$FQDN/cert.pem" -a -e "/etc/univention/ssl/$FQDN/private.key" ]; then
				cat /etc/univention/ssl/$FQDN/private.key > /etc/opsi/opsiconfd.pem
				grep -A 50 "BEGIN CERTIFICATE" /etc/univention/ssl/$FQDN/cert.pem >> /etc/opsi/opsiconfd.pem
				chmod 600 /etc/opsi/opsiconfd.pem
				chown $USER:opsiadmin /etc/opsi/opsiconfd.pem || true
			fi
			
			rm -f $PIDFILE 2>/dev/null
			set +e
			which startproc 1>/dev/null 2>/dev/null
			ret=$?
			set -e
			if [ "$ret" = "0" ]; then
				startproc -p $PIDFILE -u $USER $DAEMON -D
			else
				start-stop-daemon --chuid $USER --pidfile $PIDFILE \
					--start --quiet --oknodo --exec $DAEMON -- -D
			fi
			running=false
			i=1
			while [ "$running" != "true" -a $i -le 10 ]; do
				echo -n "."
				if ([ -f $PIDFILE ] && ps h `cat $PIDFILE` > /dev/null); then
					running=true
				else
					sleep 1
					i=$(($i+1))
				fi
			done
			
			[ "$START_GUARD" = "1" ] && $GUARD_BIN &
			
			if [ "$running" = "true" ]; then
				echo "   (done)."
			else
				echo "   (failed)."
				exit 1
			fi
		fi
		
		if ! su $USER -c "test -r /etc/shadow"; then
			echo ""
			echo "      WARNING: User $USER lacks read permission for /etc/shadow."
			echo "               PAM authentication will fail."
			echo ""
		fi
		;;
	stop)
		echo -n "Stopping opsi config service...   "
		
		# Kill opsiconfd-guard
		killall `basename $GUARD_BIN` 1>/dev/null 2>/dev/null
		
		if [ -f $PIDFILE ] && ps h `cat $PIDFILE` > /dev/null; then
			start-stop-daemon --stop --quiet --pidfile $PIDFILE > /dev/null
			echo "(done)."
		else
			echo "(not running)."
		fi
			
		;;
	reload)
		echo -n "Reloading opsi config service...   "
		
		if [ -f $PIDFILE ] && ps h `cat $PIDFILE` > /dev/null; then
			start-stop-daemon --stop --signal HUP --pidfile $PIDFILE > /dev/null
			echo "(done)."
		else
			echo "(not running)."
		fi
		
		;;
	restart|force-reload)
		$0 stop
		sleep 1
		$0 start
		;;
	
	status)
		echo -n "Checking opsi config service... "
		if [ -f $PIDFILE ] && ps h `cat $PIDFILE` > /dev/null; then
			echo "(running)."
			exit 0
		fi
		echo "(not running)."
		exit 1
	;;

	*)
		echo "Usage: /etc/init.d/opsiconfd {start|stop|status|reload|restart|force-reload}"
		exit 1
		;;
esac

exit 0

