#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
   = = = = = = = = = = = = = = = = = = = = = = =
   =   opsi configuration daemon (opsiconfd)   =
   = = = = = = = = = = = = = = = = = = = = = = =
   
   opsiconfd is part of the desktop management solution opsi
   (open pc server integration) http://www.opsi.org
   
   Copyright (C) 2008 uib GmbH
   
   http://www.uib.de/
   
   All rights reserved.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License version 2 as
   published by the Free Software Foundation.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   
   @copyright:	uib GmbH <info@uib.de>
   @author: Jan Schneider <j.schneider@uib.de>
   @license: GNU General Public License version 2
"""

__version__ = '2.0.0.15'

# Imports
import os, getopt, socket, urllib, base64
from OpenSSL import SSL

# Twisted imports
from twisted.internet import defer, threads, reactor
from twisted.python.failure import Failure
from OPSI.web2 import resource, stream, server, log, http, responsecode
from OPSI.web2.http_headers import Cookie
from OPSI.web2.channel.http import HTTPFactory
from OPSI.web2.dav import static

# OPSI imports
from OPSI import Tools
from OPSI.Logger import *
from OPSI.Backend.BackendManager import *
from OPSI.Backend.Backend import *

# Some defaults
backendManagerConf = '/etc/opsi/backendManager.d'
configFile = '/etc/opsi/opsiconfd.conf'
pidFile = '/var/run/opsiconfd.pid'
httpPort = 0
httpsPort = 4447
interface = '0.0.0.0'
sslServerKeyFile = '/etc/opsi/opsiconfd.pem'	# Server's private key file
sslServerCertFile = '/etc/opsi/opsiconfd.pem'	# Server's certificate file
sessionName = 'OPSISID'				# Session name for cookie
sessionMaxInactiveInterval = 120 		# Session expires after 120 seconds
maxExecutionStatisticValues = 250
paramLengthLogLimit = 200
resolveClientIp = True
verifyIp = False
updateHardwareAddress = True
symlinkLogs = True
logFile = None
logLevel = LOG_ERROR
logFormat = '[%l] [%D] %M (%F|%N)'
machineLogs = False
daemon = False
staticDirectories = {}
webdavDirectories = {}
startTime = time.time()

# Other globals
root = None
pid = None
statistics = { 
	'execution': [] 
}
sessionHandler = None

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                         CLASS ROOT                                                =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Root(resource.Resource):
	addSlash = True
	def render(self, request):
		''' Process GET request. '''
		return http.Response(stream="<html><head><title>opsiconfd</title></head><body></body></html>")

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                      CLASS OPSIJSONRPC                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class OpsiJsonRpc(resource.Resource):
	def getChild(self, name, request):
		''' Get the child resource for the requested path. '''
		if not name:
			return self
		return resource.Resource.getChild(self, name, request)
	
	def http_POST(self, request):
		''' Process POST request. '''
		logger.debug2("OpsiJsonRpc.http_POST()")
		worker = JsonRpcWorker(request, self, method = 'POST')
		return worker.process()
		
	def http_GET(self, request):
		''' Process GET request. '''
		logger.debug2("OpsiJsonRpc.http_GET()")
		worker = JsonRpcWorker(request, self, method = 'GET')
		return worker.process()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                   CLASS OPSIJSONINTERFACE                                         =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class OpsiJsonInterface(OpsiJsonRpc):
	def __init__(self):
		OpsiJsonRpc.__init__(self)
		bm = BackendManager(authRequired = False)
		self.possibleMethods = bm.getPossibleMethods_listOfHashes()
		self.possibleMethods.append( { 'name': 'getServerCertificate', 'params': [] } )
		bm.exit()
	
	def http_POST(self, request):
		''' Process POST request. '''
		logger.debug2("OpsiJsonInterface.http_POST()")
		worker = JsonInterfaceWorker(request, self, method = 'POST')
		return worker.process()
		
	def http_GET(self, request):
		''' Process GET request. '''
		logger.debug2("OpsiJsonInterface.http_GET()")
		worker = JsonInterfaceWorker(request, self, method = 'GET')
		return worker.process()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS OPSIDAV                                              =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class OpsiDAV(static.DAVFile):
	
	def __init__(self, path, readOnly=True, defaultType="text/plain", indexNames=None):
		static.DAVFile.__init__(self, path, defaultType, indexNames)
		self._readOnly = readOnly
	
	def createSimilarFile(self, path):
		return self.__class__(path, readOnly=self._readOnly, defaultType=self.defaultType, indexNames=self.indexNames[:])
	
	def renderHTTP(self, request):
		if self._readOnly and request.method not in ('GET', 'PROPFIND'):
			logger.warning("Command %s not allowed (readonly)" % request.method)
			return http.Response(
				code	= responsecode.FORBIDDEN,
				stream	= "Readonly!" )
		worker = DAVWorker(request, self)
		return worker.process()

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS WORKER                                               =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Worker:
	def __init__(self, request, resource, method = 'POST'):
		self.request = request
		self.resource = resource
		self.method = method
		self.session = None
		self.response = http.Response( code = responsecode.OK )
		self.result = ""
		
		self._setLogFile()
	
	def __del__(self):
		logger.exit(object = self)
	
	def _setLogFile(self):
		if machineLogs and logFile:
			logger.setLogFile( logFile.replace('%m', self.request.remoteAddr.host), object = self )
	
	def _linkLogFile(self, hostId):
		if machineLogs and logFile and symlinkLogs:
			logger.linkLogFile( logFile.replace('%m', hostId), object = self )
	
	def process(self):
		try:
			self.deferred = defer.Deferred()
			self.deferred.addCallback(self._getSession)
			self.deferred.addCallback(self._getQuery)
			self.deferred.addCallback(self._getRpc)
			self.deferred.addCallback(self._authenticate)
			self.deferred.addCallback(self._executeRpc)
			# Convert ints to strings to prevent problems with delphi libraries
			self.deferred.addCallback(self._returnResponse)
			self.deferred.addErrback(self._errback)
			self.deferred.callback(None)
			return self.deferred
		except Exception, e:
			return self._errback(e)
	
	def _getQuery(self, result):
		self.query = ''
		if (self.method == 'GET'):
			self.query = urllib.unquote( self.request.querystring )
		elif (self.method == 'POST'):
			# Returning deferred needed for chaining
			d = stream.readStream(self.request.stream, self._handlePostData)
			d.addErrback(self._errback)
			return d
		
	def _getRpc(self, result):
		if not self.query:
			raise Exception('Got no query')
		
		try:
			# Deserialize json-object
			self.rpc = json.read(self.query)
			if not self.rpc.get('id'):
				raise Exception('No id defined!')
			self.result['id'] = self.rpc['id']
			if not self.rpc.get('method'):
				raise Exception('No method defined!')
		except Exception, e:
			e = str(e)
			logger.warning("Failed to get rpc from query '%s': %s" % 
					(self.query, e) )
			# Bad request
			self.response.code = responsecode.BAD_REQUEST
			self.result['error'] = e
			raise
		
		rpc = str(self.rpc)
		if (len(rpc) > paramLengthLogLimit+103):
			# Do not log long strings like used in writeLog
			rpc = rpc[:paramLengthLogLimit+100] + '...'
		logger.info('Got json-rpc request: %s' % rpc)
		
		
	def _getSession(self, result):
		''' This method restores a session or generates a new one. '''
		self.session = None
		
		logger.confidential("Request headers: %s " % self.request.headers)
		
		# Get session id from cookie request header
		sessionId = ''
		try:
			sessionId = self.request.headers.getHeader('cookie')[0].value
		except Exception, e:
			pass
		
		if not sessionId:
			logger.notice("Client '%s' did not send cookie" % self.request.remoteAddr.host)
		
		# Get Session object
		self.session = sessionHandler.getSession(sessionId)
		
		if self.session.ip and verifyIp and (self.session.ip != self.request.remoteAddr.host):
			logger.critical("Client ip '%s' does not match session ip '%s'" \
				% (self.request.remoteAddr.host, self.session.ip) )
			sessionHandler.deleteSession(self.session.uid)
			self.session = sessionHandler.getSession()
		
		# Set ip
		self.session.ip = self.request.remoteAddr.host
		
		if (sessionId == self.session.uid):
			logger.info("Reusing session for client '%s'" % self.request.remoteAddr.host)
		
		logger.confidential("Session id is '%s'" % self.session.uid)
		
		# Set last modified to current time
		self.session.touch()
		
		# Add cookie to headers
		cookie = Cookie(self.session.name, self.session.uid, path='/')
		self.response.headers.setHeader('set-cookie', [ cookie ] )
		
		# Set hostname
		if not self.session.hostname:
			hostname = ''
			if resolveClientIp:
				try:
					hostname = socket.getfqdn(self.request.remoteAddr.host).lower()
					if re.search('^\d+\.\d+\.\d+\.\d+$', hostname):
						logger.error("Cannot get fqdn for client '%s'" % self.request.remoteAddr.host)
						hostname = ''
					elif (hostname != 'localhost') and (len(hostname.split('.')) == 1):
						logger.warning("Cannot get fqdn but hostname '%s' for client '%s'" \
							% (hostname, self.request.remoteAddr.host) )
						
						defaultDomain = '.'.join(socket.getfqdn().split('.')[1:])
						if not defaultDomain:
							logger.error("Cannot get fqdn for client %s (%s), missing domain, failed to add default domain." \
										% (hostname, self.request.remoteAddr.host) )
						
						logger.notice("Adding domain '%s' to hostname '%s' for client '%s'" \
								% (defaultDomain, hostname, self.request.remoteAddr.host) )
						hostname = hostname + '.' + defaultDomain
				except Exception, e:
					logger.warning("Failed to resolve address '%s': %s" % (self.request.remoteAddr.host, e))
			
			logger.info("Storing hostname '%s' in session" % hostname)
			self.session.hostname = hostname
		
		# Set user and password
		if not self.session.user and not self.session.password and self.request.headers.getHeader('Authorization'):
			(user, password) = ('', '')
			logger.debug("Trying to get username and password from Authorization header")
			auth = self.request.headers.getHeader('Authorization')
			if auth:
				logger.debug("Authorization header found (type: %s)" % auth[0])
				try:
					encoded = auth[1]
					(user, password) = base64.decodestring(encoded).split(':', 1)
					logger.confidential("Client supplied username '%s' and password '%s'" % (user, password))
				except Exception:
					logger.error("Bad Authorization header from '%s': %s" % (self.request.remoteAddr.host, e))
				
			self.session.user = user
			self.session.password = password
		
		logger.confidential("Session content: %s" % self.session.__dict__)
	
	def _authenticate(self, result):
		''' This function tries to authenticate a user.
		    Raises an exception on authentication failure. '''
		
		try:
			if self.session.authenticated:
				return
			
			if hasattr(self, 'rpc') and \
			   ( self.rpc['method'] in ('getHostId', 'getPossibleMethods_listOfHashes') or \
			     ( self.rpc['method'] == 'getDomain') and ( (len(self.rpc['params']) < 1) or not self.rpc['params'][0] ) ):
				logger.info("Allowing method '%s' without authentication" % self.rpc['method'])
				return
			
			isHost = False
			
			user = self.session.user
			if not user:
				isHost = True
				user = self.session.hostname
			
			logger.notice( "Authorization request from %s@%s" % (user, self.session.ip) )
			if not user:
				raise Exception("Cannot authenticate, no username given")
			
			if ( len(user.split('.')) > 2 ):
				# Username is something like xxx.yyy.zzz 
				# Assuming host is using FQDN to log in
				isHost = True
				
				if not self.session.hostname:
					self.session.hostname = user
				
				if (user != socket.getfqdn()):
					addressList = []
					try:
						(name, aliasList, addressList) = socket.gethostbyname_ex(user)
					except Exception, e:
						logger.warning("Failed to resolve hostname '%s': %s" % (user, e))
					
					if self.session.ip not in addressList:
						# Username (FQDN) of peer does not resolve to peer's ip address
						if verifyIp:
							logger.critical("Host login attempt with username '%s'" % user +
									" from ip '%s', but name resolves to '%s' (access denied)" % 
									( self.session.ip, addressList) )
							raise Exception("Access denied for username '%s' from '%s'" %
									(user, self.session.ip) )
						else:
							logger.notice("Host login attempt with username '%s'" % user +
									" from ip '%s', but name resolves to '%s', ip verification is disabled (access granted)" % 
									( self.session.ip, addressList) )
			
			# Create BackendManager instance
			bm = BackendManager(	username	= user,
						password	= self.session.password,
						configFile	= backendManagerConf )
			
			logger.notice('BackendManager created.')
			
			self.session.authenticated = True
			# Store BackendManager instance reference in session
			self.session.bm = bm
			
			self.session.possibleMethods = bm.getPossibleMethods_listOfHashes()
			self.session.possibleMethods.append( { 'name': 'getServerCertificate', 'params': [] } )
			
			if isHost and user not in bm.getDepotIds_list():
				try:
					bm.getHost_hash(user)
				except Exception, e:
					logger.warning("Failed to get host info for client '%s', trying to create client" % user)
					parts = user.split('.')
					domain = parts[1]
					if (len(parts) > 2):
						domain = '.'.join(parts[1:])
					bm.createClient(parts[0], domain)
				
				bm.setHostLastSeen(user, timestamp())
				self._linkLogFile(user)
				
		except Exception, e:
			# Forbidden
			#logger.logException(e)
			logger.error("Forbidden: %s" % str(e))
			self.session.user = ''
			self.session.password = ''
			self.response.code = responsecode.UNAUTHORIZED
			self.response.headers.setHeader('www-authenticate', [('basic', { 'realm': 'OPSI Configuration Service' } )])
			#self.result['error'] = str(e)
			raise
	
	def _executeRpc(self, result):
		''' Execute json remote procedure call. '''
		if (self.rpc['method'] == 'getHostId'):
			hostname = None
			if self.rpc['params']:
				hostname = self.rpc['params'][0]
			self.result['result'] = self._getHostId(hostname)
			return
		
		if (self.rpc['method'] == 'getDomain') and ( (len(self.rpc['params']) < 1) or not self.rpc['params'][0] ):
			self.result['result'] = self._getDomain()
			return
		
		if (self.rpc['method'] == 'getPossibleMethods_listOfHashes'):
			if self.session.possibleMethods:
				self.result['result'] = self.session.possibleMethods
			else:
				bm = BackendManager(authRequired = False)
				possibleMethods = bm.getPossibleMethods_listOfHashes()
				possibleMethods.append( { 'name': 'getServerCertificate', 'params': [] } )
				bm = None
				self.result['result'] = possibleMethods
			return
		
		d = threads.deferToThread(self._realRpc)
		d.addErrback(self._errback)
		return d
	
	def _getHostId(self, hostname=''):
		if hostname:
			return '%s.%s' % (hostname, self._getDomain())
		return getattr(self.session, 'hostname')
		
	def _getDomain(self):
		defaultDomain = '.'.join(socket.getfqdn().split('.')[1:])
		if not defaultDomain:
			raise Exception("Failed to get default domain")
		return defaultDomain
		
	def _realRpc(self):
		method = self.rpc.get('method')
		params = self.rpc.get('params')
		ps = str(params)
		if (len(ps) > paramLengthLogLimit):
			# Do not log long strings like used in writeLog
			ps = ps[:paramLengthLogLimit-3] + '...'
		logger.info("RPC method: '%s' params: '%s'" % (method, ps))
		
		# Get BackendManager instance from session
		try:
			bm = self.session.bm
		except Exception, e:
			logger.critical("Failed to execute rpc, cannot get bm instance from session!")
			logger.critical("rpc is: %s" % self.rpc)
			logger.critical("session is: %s" % self.session)
			logger.notice("Deleting session!")
			sessionHandler.deleteSession(self.session.uid)
			raise Exception("Failed to execute rpc, cannot get bm instance from session!")
		
		if (method == 'exit'):
			sessionHandler.deleteSession(self.session.uid)
			return
		
		if (method == 'getServerCertificate'):
			try:
				cert = ""
				f = open(sslServerCertFile)
				begin = False
				for line in f.readlines():
					if begin and (line.strip() == "-----END CERTIFICATE-----"):
						cert += line
						break
					if begin or (line.strip() == "-----BEGIN CERTIFICATE-----"):
						begin = True
						cert += line
				f.close()
				if not cert:
					raise Exception("failed to read cert file '%s'" % sslServerCertFile)
				self.result['result'] = cert
				return
			except Exception, e:
				logger.error("Failed to get certificate: %s" % e)
				self.result['error'] = { 'class': 'BackendMissingDataError', 'message': "Failed to get certificate" }
				return
			
		# Check if possible method
		valid = False
		for f in self.session.possibleMethods:
			if (f['name'] == method):
				valid = True
		
		try:
			if not valid:
				raise BackendBadValueError("Method '%s' is not valid" % method)
			
			ps = str(params)
			if (len(ps) > paramLengthLogLimit):
				# Do not log long strings like used in writeLog
				ps = ps[:paramLengthLogLimit-3] + '...'
			logger.info( "Executing:  %s(%s)" % (method, ps) )
			
			# Execute method
			start = time.time()
			self.result['result'] = eval( "bm.%s(%s)" % (method, str(params)[1:-1]) )
		except(BackendError, BackendTemporaryError,
		       BackendBadValueError, BackendMissingDataError, 
		       BackendIOError, BackendPermissionDeniedError,
		       BackendAuthenticationError), e:
			logger.error(e)
			self.result['error'] = { 'class': e.__class__.__name__, 'message': str(e) }
			self.result['result'] = None
			return
		
		logger.info('Got result...')
		duration = round(time.time() - start, 3)
		
		if (maxExecutionStatisticValues > 0):
			global statistics
			statistics['execution'].append(
				{ "method": method, "params": params, "duration": duration }
			)
			if (len(statistics['execution']) > maxExecutionStatisticValues):
				statistics['execution'] = statistics['execution'][1:]
		
		ps = str(params)[1:-1]
		if (len(ps) > paramLengthLogLimit):
			# Do not log long strings like used in writeLog
			ps = ps[:paramLengthLogLimit-3] + '...'
		logger.info('Took %0.3fs to process %s(%s)' % (duration, method, ps))
	
	def _handlePostData(self, chunk):
		logger.debug2("_handlePostData %s" % chunk)
		self.query += chunk
	
	def _returnResponse(self, result):
		self.response.stream = stream.IByteStream(self.result)
		return self.response
	
	def _errback(self, failure):
		if (self.response.code == responsecode.OK):
			# Do not overwrite responsecodes set earlier
			self.response.code = responsecode.INTERNAL_SERVER_ERROR
		
		if isinstance(failure, Failure):
			self.result = failure.getErrorMessage()
			logger.critical(failure.getTraceback())
		else:
			self.result = str(failure)
		logger.error("Failed to process request: %s" % self.result)
		return self._returnResponse(None)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS JSONRPCWORKER                                           =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class JsonRpcWorker(Worker):
	def __init__(self, request, resource, method = 'POST'):
		Worker.__init__(self, request, resource, method)
		self.rpc = {"id": None, "method": None, "params": []}
		self.result = {"id": None, "result": None, "error": None}
		
	def _allIntsToString(self, obj):
		if ( type(obj) == type([]) ):
			for i in range( len(obj) ):
				obj[i] = self._allIntsToString(obj[i])
		
		elif ( type(obj) == type({}) ):
			for (key, value) in obj.items():
				obj[key] = self._allIntsToString(value)
		elif ( type(obj) == type(1) ):
			obj = str(obj)
		return obj
	
	def _returnResponse(self, result):
		self.result['result'] = self._allIntsToString(self.result['result'])
		jsonResult = ''
		try:
			jsonResult = json.write( self.result )
		except Exception, e:
			logger.critical(e)
		self.response.stream = stream.IByteStream(jsonResult)
		return self.response
	
	def _errback(self, failure):
		if (self.response.code == responsecode.OK):
			# Do not overwrite responsecodes set earlier
			self.response.code = responsecode.INTERNAL_SERVER_ERROR
		
		if isinstance(failure, Failure):
			if not self.result['error']:
				self.result['error'] = failure.getErrorMessage()
			logger.critical(failure.getTraceback())
		else:
			if not self.result['error']:
				self.result['error'] = str(failure)
		logger.error("Failed to process rpc: %s" % self.result['error'])
		return self._returnResponse(None)
		
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                  CLASS JSONINTERFACEWORKER                                        =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class JsonInterfaceWorker(JsonRpcWorker):
	xhtml = """
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>opsi configuration interface</title>
		<style>
		input, select {
			background-color: #fafafa;
			border-color: #abb1ef;
			border-width: 1px;
			border-style: solid;
			font-family: verdana, arial;
			font-size: 12px;
			width: 280px;
		}
		.json {
			background-color: #fafafa;
			border-color: #abb1ef;
			border-width: 1px;
			border-style: dashed;
			font-family: verdana, arial;
			font-size: 11px;
			padding: 10px;
			color: #555555;
		}
		.json_key {
			color: #9e445a;
		}
		.json_label {
			color: #abb1ef;
			margin-top: 20px;
			margin-bottom: 5px;
			font-family: verdana, arial;
			font-size: 11px;
		}
		.title {
			color: #555555; 
			font-size: 20px; 
			font-weight: bolder; 
			letter-spacing: 5px;
		}
		.button {
			background-color: #fafafa;
			border: none;
			margin-top: 20px;
			color: #9e445a;
			font-weight: bolder;
		}
		.box {
			background-color: #fafafa;
			border-color: #555555;
			border-width: 2px;
			border-style: solid;
			padding: 20px;
			margin: 30px;
			font-family: verdana, arial;
			font-size: 12px;
		}
		</style>
		<script type="text/javascript">
			var parameters = new Array();
			var method = '';
			var params = '';
			var id = '"id": 1';
%s
			function selectFunction(select) {
				method = select.value;
				tbody = document.getElementById('tbody');
				var button;
				var json;
				for (i=tbody.childNodes.length-1; i>=0; i--) {
					if (tbody.childNodes[i].id == 'tr_method') {
					}
					else if (tbody.childNodes[i].id == 'tr_submit') {
						button = tbody.childNodes[i];
						tbody.removeChild(button);
					}
					else if (tbody.childNodes[i].id == 'tr_json') {
						json = tbody.childNodes[i];
						tbody.removeChild(json);
					}
					else {
						tbody.removeChild(tbody.childNodes[i]);
					}
				}

				for (i=0; i < parameters[select.value].length; i++) {
					tr = document.createElement("tr");
					td1 = document.createElement("td");
					text = document.createTextNode(parameters[select.value][i] + ":");
					td1.appendChild(text);
					td2 = document.createElement("td");
					input = document.createElement("input");
					input.setAttribute('onchange', 'jsonString()');
					input.setAttribute('type', 'text');
					td2.appendChild(input);
					tr.appendChild(td1);
					tr.appendChild(td2);
					tbody.appendChild(tr)
				}
				tbody.appendChild(json)
				tbody.appendChild(button)
				
				jsonString();
			}
			
			function onSubmit() {
				var json = '{ "id": 1, "method": ';
				json += document.getElementById('json_method').firstChild.data;
				json += ', "params": ';
				json += document.getElementById('json_params').firstChild.data;
				json += ' }';
				window.location.href = '?' + json;
				return false;
			}
			
			function jsonString() {
				span = document.getElementById('json_method');
				for (i=span.childNodes.length-1; i>=0; i--) {
					span.removeChild(span.childNodes[i])
				}
				span.appendChild(document.createTextNode('"' + method + '"'));
				
				span = document.getElementById('json_params');
				for (i=span.childNodes.length-1; i>=0; i--) {
					span.removeChild(span.childNodes[i])
				}
				params = '['
				inputs = document.getElementsByTagName('input');
				for (i=0; i<inputs.length; i++) {
					if (inputs[i].id != 'submit') {
						if (inputs[i].value == '') {
							i = inputs.length;
						}
						else {
							if (i>0) {
								params += ', ';
							}
							params += inputs[i].value.replace(/\\\/g, '\\\\\\\\');
						}
					}
				}
				span.appendChild(document.createTextNode(params + ']'));
			}
		</script>
	</head>
	<body onload="selectFunction(document.getElementById('select'))">
		<div class="title">opsi config interface</div>
		<form action="cgi" method="post" onsubmit="return onSubmit()">
			<table class="box">
			<tbody id="tbody">
				<tr id="tr_method">
					<td style="width: 120px;">Method:</td>
					<td style="width: 280px;">
						<select id="select" onchange="selectFunction(this)" name="method">
%s
						</select>
					</td>
				</tr>
				<tr id="tr_json">
					<td colspan="2">
						<div class="json_label">
							resulting json remote procedure call:
						</div>
						<div class="json">
							{&nbsp;"<font class="json_key">method</font>": <span id="json_method"></span>,<br />
							&nbsp;&nbsp;&nbsp;"<font class="json_key">params</font>": <span id="json_params">[]</span>,<br />
							&nbsp;&nbsp;&nbsp;"<font class="json_key">id</font>": 1 }
						</div>
					</td>
				</tr>
				<tr id="tr_submit">
					<td align="center" colspan="2">
						<input value="Execute" id="submit" class="button" type="submit" />
					</td>
				</tr>
			</tbody>
			</table>
		</form>
		<div>
			<div class="json_label">
				json-rpc result
			</div>
			<div class="json">
				<pre>%s</pre>
			</div>
		</div>
	</body>
</html>"""

	def __init__(self, request, resource, method = 'POST'):
		JsonRpcWorker.__init__(self, request, resource, method)
	
	def _returnResponse(self, result):
		js = ''
		sel = ''
		for f in self.resource.possibleMethods:
			js += "\t\t\tparameters['%s'] = new Array();\r\n" % (f['name'])
			for p in range(len(f['params'])):
				js += "\t\t\tparameters['%s'][%s]='%s';\r\n" % (f['name'], p, f['params'][p])
			if (f['name'] == self.rpc['method']):
				sel += '\t\t\t\t\t\t\t<option selected>%s</option>\r\n' % f['name']
			else:
				sel += '\t\t\t\t\t\t\t<option>%s</option>\r\n' % f['name']
		
		self.response.stream = stream.IByteStream(self.xhtml % (js, sel, str(Tools.jsonObjToHtml(self.result))))
		return self.response
	
	def _errback(self, failure):
		if (self.response.code == responsecode.OK):
			# Do not overwrite responsecodes set earlier
			self.response.code = responsecode.INTERNAL_SERVER_ERROR
		
		if isinstance(failure, Failure):
			if not self.result['error']:
				self.result['error'] = failure.getErrorMessage()
			logger.critical(failure.getTraceback())
		else:
			if not self.result['error']:
				self.result['error'] = str(failure)
		logger.error("Failed to process rpc: %s" % self.result['error'])
		return self._returnResponse(None)
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                        CLASS DAVWORKER                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class DAVWorker(Worker):
	def __init__(self, request, resource):
		Worker.__init__(self, request, resource, 'POST')
		
	def process(self):
		try:
			self.deferred = defer.Deferred()
			self.deferred.addCallback(self._getSession)
			self.deferred.addCallback(self._authenticate)
			self.deferred.addCallback(self._render)
			self.deferred.addCallback(self._addCookie)
			self.deferred.addErrback(self._errback)
			self.deferred.callback(None)
			return self.deferred
		except Exception, e:
			return self._errback(e)
		
	def _addCookie(self, result):
		# Add cookie to headers
		cookie = Cookie(self.session.name, self.session.uid, path='/')
		result.headers.setHeader('set-cookie', [ cookie ] )
		return result
		
	def _render(self, result):
		if False:#if not self.session.bm.userIsHost() and not self.session.bm.userIsAdmin():
			logger.warning("WebDAV access denied for user %s@%s" % (self.session.user, self.session.ip))
			self.response.code = responsecode.UNAUTHORIZED
			raise Exception("WebDAV access denied!")
			
		d = super(OpsiDAV, self.resource).renderHTTP(self.request)
		if isinstance(d, defer.Deferred):
			d.addErrback(self._errback)
		return d
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                         CLASS SESSION                                             =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class Session:
	def __init__(self, sessionHandler, name = 'OPSISID', sessionMaxInactiveInterval = 120):
		self.sessionHandler = sessionHandler
		self.name = name
		self.sessionMaxInactiveInterval = sessionMaxInactiveInterval
		self.sessionTimer = None
		self.uid = Tools.randomString(32)
		self.ip = ''
		self.hostname = ''
		self.user = ''
		self.password = ''
		self.authenticated = False
		self.bm = None
		self.possibleMethods = []
		self.touch()
		
	def touch(self):
		self.lastModified = time.time()
		if self.sessionTimer:
			self.sessionTimer.cancel()
		self.sessionTimer = threading.Timer(self.sessionMaxInactiveInterval, self.expire)
		self.sessionTimer.start()
	
	def expire(self):
		self.sessionHandler.sessionExpired(self)
	
	def __del__(self):
		if self.sessionTimer:
			self.sessionTimer.cancel()
	
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                     CLASS SESSIONHANDLER                                          =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SessionHandler:
	def __init__(self, sessionName = 'OSPISID', sessionMaxInactiveInterval = 120):
		self.sessionName = sessionName
		self.sessionMaxInactiveInterval = sessionMaxInactiveInterval
		self.sessions = {}
	
	def stop(self):
		self.deleteAllSessions()
	
	def getSession(self, uid):
		session = self.sessions.get(uid)
		if session:
			return session
		return self.createSession()
	
	def createSession(self):
		session = Session(self, self.sessionName, self.sessionMaxInactiveInterval)
		self.sessions[session.uid] = session
		logger.notice("New session created")
		return session
	
	def sessionExpired(self, session):
		try:
			logger.info("Session '%s' expired after %d seconds" % (session.uid, (time.time()-session.lastModified)))
			if session.sessionTimer:
				session.sessionTimer.cancel()
			session.bm.exit()
		except:
			pass
		
		try:
			del self.sessions[session.uid]
			logger.info("Session '%s' deleted" % session.uid)
		except:
			pass
		
	def deleteSession(self, uid):
		session = self.sessions.get(uid)
		if not session:
			logger.warning('No such session id: %s' % uid)
			return
		
		try:
			if session.sessionTimer:
				session.sessionTimer.cancel()
				logger.info("Session timer canceled")
			session.bm.exit()
		except:
			pass
		
		try:
			del self.sessions[uid]
			logger.notice("Session '%s' deleted" % uid)
		except KeyError:
			pass
		
	
	def deleteAllSessions(self):
		for (uid, session) in self.sessions.items():
			logger.notice("Deleting session '%s'" % uid)
			self.deleteSession(uid)
		self.sessions = {}
		
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                       CLASS SSLCONTEXT                                            =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
class SSLContext:
	def getContext(self):
		''' Create an SSL context. '''
		
		# Test if server certificate and key file exist.
		if not os.path.isfile(sslServerKeyFile):
			raise Exception("Server key file '%s' does not exist!" % sslServerKeyFile)
			
		if not os.path.isfile(sslServerCertFile):
			raise Exception("Server certificate file '%s' does not exist!" % sslServerCertFile)
		
		context = SSL.Context(SSL.SSLv23_METHOD)
		context.use_privatekey_file(sslServerKeyFile)
		context.use_certificate_file(sslServerCertFile)
		return context

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# =                                            MAIN                                                   =
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

def readConfigFile():
	''' Get settings from config file '''
	logger.notice("Trying to read config from file: '%s'" % configFile)
	
	try:
		# Import File Module
		from OPSI.Backend.File import File
			
		# Read Config-File
		config = File().readIniFile(configFile, caseIgnore = False, raw = True)
		
		for section in config.sections():
			logger.debug("Processing section '%s' in config file: '%s'" % (section, configFile))
			if (section.lower() == 'global'):
				# Global settings
				for (option, value) in config.items(section):
					if (option.lower() == 'bm config'):
						if os.name == 'posix':
							global backendManagerConf
							backendManagerConf = value.strip()
					elif (option.lower() == 'pid file'):
						if os.name == 'posix':
							global pidFile
							pidFile = value.strip()
					elif (option.lower() == 'log level'):
						global logLevel
						logLevel = int(value.strip())
					elif (option.lower() == 'log file'):
						if os.name == 'posix':
							global logFile
							logFile = value.strip()
					elif (option.lower() == 'log format'):
						global logFormat
						logFormat = value.strip()
					elif (option.lower() == 'symlink logs'):
						global symlinkLogs
						if value.strip().lower() in ('1', 'true', 'yes'):
							symlinkLogs = True
						else:
							symlinkLogs = False
					elif (option.lower() == 'max execution statistics'):
						global maxExecutionStatisticValues
						maxExecutionStatisticValues = int(value.strip())
					else:
						logger.warning("Ignoring unknown option '%s' in config file: '%s'" % (option, configFile))
			
			elif (section.lower() == 'service'):
				# Service settings
				for (option, value) in config.items(section):
					if (option.lower() == 'http port'):
						global httpPort
						httpPort = int(value.strip())
					elif (option.lower() == 'https port'):
						global httpsPort
						httpsPort = int(value.strip())
					elif (option.lower() == 'interface'):
						global interface
						interface = value.strip()
					elif (option.lower() == 'ssl server cert'):
						if os.name == 'posix':
							global sslServerCertFile
							sslServerCertFile = value.strip()
					elif (option.lower() == 'ssl server key'):
						if os.name == 'posix':
							global sslServerKeyFile
							sslServerKeyFile = value.strip()
					else:
						logger.warning("Ignoring unknown option '%s' in config file: '%s'" % (option, configFile))
			
			elif (section.lower() == 'session'):
				# Session settings
				for (option, value) in config.items(section):
					if (option.lower() == 'session name'):
						global sessionName
						sessionName = value.strip()
					elif (option.lower() == 'resolve ip'):
						global resolveClientIp
						if value.strip().lower() in ('1', 'true', 'yes'):
							resolveClientIp = True
						else:
							resolveClientIp = False
					elif (option.lower() == 'verify ip'):
						global verifyIp
						if value.strip().lower() in ('1', 'true', 'yes'):
							verifyIp = True
						else:
							verifyIp = False
					elif (option.lower() == 'max inactive interval'):
						global sessionMaxInactiveInterval
						sessionMaxInactiveInterval = int(value.strip())
					elif (option.lower() == 'update hardware address'):
						global updateHardwareAddress
						if value.strip().lower() in ('1', 'true', 'yes'):
							updateHardwareAddress = True
						else:
							updateHardwareAddress = False
					else:
						logger.warning("Ignoring unknown option '%s' in config file: '%s'" % (option, configFile))
			
			elif (section.lower() == 'directories'):
				# Static directories
				global staticDirectories
				staticDirectories = {}
				
				for (option, value) in config.items(section):
					if os.name == 'posix':
						staticDirectories[option] = value
					else:
						if option == 'configed':
							staticDirectories[option] = windefaultdir+'\\configed.exe'
						if option == '/':
							staticDirectories[option] = windefaultdir+'\\share'
			
			else:
				logger.warning("Ignoring unknown section '%s' in config file: '%s'" % (section, configFile))
	
	except Exception, e:
		# An error occured while trying to read the config file
		logger.error("Failed to read config file '%s': %s" % (configFile, e))
		logger.logException(e)
		raise
	logger.notice("Config read")
	
def logStatistics():
	logger.debug("Logging statistics")
	global statistics
	minimum = 1000000
	maximum = 0
	summation = 0
	
	if (len(statistics['execution']) <= 0):
		logger.notice("No execution statistics found.")
		return
	
	for e in statistics['execution']:
		if (e['duration'] < minimum):
			minimum = e['duration']
		if (e['duration'] > maximum):
			maximum = e['duration']
		summation += e['duration']
		logger.info("Execution time statistics: duration %0.3fs, method '%s'" % (e['duration'], e['method']))
		#logger.info("Execution time statistics: duration %ss, method '%s', params '%s'" \
		#	% (e['duration'], e['method'], e['params']))
	
	average = round(summation/len(statistics['execution']), 3)
	logger.notice("Execution time statistics: minimum %0.3fs, maximum %0.3fs, average %0.3fs" \
		% (minimum, maximum, average))
	
	# Cleanup
	statistics = { 'execution': [] }
	
def signalHandler(signo, stackFrame):
	
	if (signo == SIGHUP):
		secs = time.time()-startTime
		d = int( (secs/(60*60*24)) )
		h = int( (secs-(d*60*60*24))/(60*60) )
		m = int( (secs-(d*60*60*24)-(h*60*60))/60 )
		s = int( (secs-(d*60*60*24)-(h*60*60)-(m*60)) )
		logger.notice("Started at %s, running %d day(s), %02d:%02d:%02d" % (
					time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(startTime)), d, h, m, s ) )
		logger.notice("Got signal %s, deleting all active sessions..." % signo)
		sessionHandler.deleteAllSessions()
		
		logger.notice("Got signal %s, logging execution statistics..." % signo)
		logStatistics()
		
		logger.notice("Got signal %s, re-reading config file '%s'..." % (signo, configFile) )
		try:
			readConfigFile()
			setLogLevel(logLevel)
			setLogFile(logFile)
			setLogFormat(logFormat)
		except:
			pass
		
	if (signo == SIGTERM or signo == SIGINT):
		logger.notice("Got signal %s, exiting..." % signo)
		logger.debug("Stopping session handler")
		sessionHandler.stop()
		logger.debug("Session handler stopped")
		if reactor.running:
			logger.debug("Stopping reactor")
			reactor.stop()
			logger.debug("Reactor stopped")
		logStatistics()

def createRoot():
	global root
	
	if staticDirectories.get('/'):
		if not os.path.isdir(staticDirectories.get('/')):
			logger.error("Cannot add static content '/': directory '%s' does not exist." \
				% staticDirectories.get('/'))
			root = Root()
		else:
			root = static.File(staticDirectories.get('/'))
			logger.notice("Added static content '/' which points to directory '%s'" \
				% staticDirectories.get('/'))
	
	else:
		root = Root()
	
	root.putChild("rpc", OpsiJsonRpc())
	root.putChild("interface", OpsiJsonInterface())
	
	for (name, path) in staticDirectories.items():
		if (name == '/'):
			continue
		
		if name in ("rpc", "interface"):
			logger.error("Cannot add static content '%s', already in use!" % name)
			continue
		
		if not os.path.isdir(path):
			logger.error("Cannot add static content '%s': directory '%s' does not exist." % (name, path))
			continue
		
		if (name == 'configed'):
			root.putChild(name, static.File(path))
			logger.notice("Added static content '%s' which points to directory '%s'" % (name, path))
			continue
		
		root.putChild(name, OpsiDAV(path, readOnly=True))
		
		logger.notice("Added webdav content '%s' which points to directory '%s'" % (name, path))
	
	bm = BackendManager(authRequired = False)
	fqdn = socket.getfqdn()
	if fqdn in bm.getDepotIds_list():
		depot = bm.getDepot_hash(fqdn)
		logger.debug("Depot info: %s" % depot)
		repositoryLocalUrl = depot.get('repositoryLocalUrl')
		if not repositoryLocalUrl:
			raise Exception("Repository local url for depot '%s' not found" % fqdn)
		if not repositoryLocalUrl.startswith('file:///'):
			raise Exception("Repository local url '%s' not allowed" % repositoryLocalUrl)
		path = repositoryLocalUrl[7:]
		if not os.path.isdir(path):
			raise Exception("Cannot add webdav content 'products': directory '%s' does not exist." % path)
		if not os.access(path, os.R_OK | os.W_OK | os.X_OK):
			raise Exception("Cannot add webdav content 'products': permissions on directory '%s' not sufficient." % path)
		
		root.putChild('products', OpsiDAV(path, readOnly=False))
		logger.notice("Added static content 'products' which points to directory '%s'" % path)
	bm.exit()
	
def daemonize():
	# Fork to allow the shell to return and to call setsid
	try:
		pid = os.fork()
		if (pid > 0):
			# Parent exits
			sys.exit(0)
	except OSError, e:
		raise Exception("First fork failed: %e" % e)
	
	# Do not hinder umounts
	os.chdir("/")
	# Create a new session
	os.setsid()
	
	# Fork a second time to not remain session leader
	try:
		pid = os.fork()
		if (pid > 0):
			sys.exit(0)
	except OSError, e:
		raise Exception("Second fork failed: %e" % e)
	
	logger.setConsoleLevel(LOG_NONE)
	
	# Close standard output and standard error.
	os.close(0)
	os.close(1)
	os.close(2)
	
	# Open standard input (0)
	if (hasattr(os, "devnull")):
		os.open(os.devnull, os.O_RDWR)
	else:
		os.open("/dev/null", os.O_RDWR)
	
	# Duplicate standard input to standard output and standard error.
	os.dup2(0, 1)
	os.dup2(0, 2)
	sys.stdout = logger.getStdout()
	sys.stderr = logger.getStderr()
	
	
def setLogLevel(level):
	logLevel = level
	
	if not daemon:
		logger.setConsoleLevel(logLevel)
		logger.setConsoleColor(True)
	
	if logFile:
		logger.setFileLevel(logLevel)
		logger.setSyslogLevel(LOG_NONE)
	else:
		logger.setSyslogLevel(logLevel)
		logger.setFileLevel(LOG_NONE)

def setLogFile(lFile):
	logFile = lFile
	
	global machineLogs
	if logFile:
		if (logFile.find('%m') != -1):
			machineLogs = True
			logger.setLogFile( logFile.replace('%m', 'opsiconfd') )
		else:
			logger.setLogFile( logFile )
	else:
		machineLogs = False

def setLogFormat(format):
	logFormat = format
	
	logger.setLogFormat(logFormat)

def usage():
	print "\nUsage: %s [-D] [-c <filename>] [-f <filename>] [-l <log level>] [-i <ipaddress>] [-p <http port>] [-P <https port>]" % os.path.basename(sys.argv[0])
	print "Options:"
	print "  -v    Show version information and exit"
	print "  -D    Causes the server to operate as a daemon"
	print "  -p    HTTP Port to listen on (0 to disable)"
	print "  -P    HTTPS Port to listen on (0 to disable)"
	print "  -i    IP address of interface to listen on (default: 0.0.0.0)"
	print "  -f    Log to given file instead of syslog"
	print "  -c    Location of config file"
	print "  -l    Set log level (default: 4)"
	print "        0=nothing, 1=critical, 2=error, 3=warning, 4=notice, 5=info, 6=debug"
	print ""

def main(argv):
	global pid
	global daemon
	global site
	global sessionHandler
	global configFile
	global logFormat
	global logLevel
	global logFile
	global httpPort
	global httpsPort
	global interface
	
	# Set umask
	os.umask(0077)
	
	# Get Logger instance
	logger = Logger()
	setLogFormat(logFormat)
	setLogLevel(logLevel)
	
	# Process command line arguments
	try:
		(opts, args) = getopt.getopt(argv, "vc:f:l:p:P:i:D")

	except getopt.GetoptError:
		usage()
		sys.exit(1)
	
	for (opt, arg) in opts:
		if (opt == "-c"):
			configFile = arg
	
	try:
		readConfigFile()
	except Exception, e:
		print >> sys.stderr, str(e)
		
	for (opt, arg) in opts:
		if   (opt == "-v"):
			print "opsiconfd version %s" % __version__
			sys.exit(0)
		if   (opt == "-D"):
			daemon = True
		elif (opt == "-l"):
			logLevel = int(arg)
		elif (opt == "-f"):
			logFile = arg
		elif (opt == "-p"):
			httpPort = int(arg)
		elif (opt == "-P"):
			httpsPort = int(arg)
		elif (opt == "-i"):
			interface = arg
	
	if daemon:
		daemonize()
	
	setLogFile(logFile)
	setLogLevel(logLevel)
	setLogFormat(logFormat)
	
	logger.comment(	"\n==================================================================\n" \
			+ "             OPSI configuration-service starting" + \
			"\n==================================================================\n")
	
	# Test backendmanager
	bm = BackendManager(authRequired = False)
	bm.exit()
	
	if os.path.exists(pidFile):
		if (os.name == 'posix'):
			pf = open(pidFile, 'r')
			p = pf.readline().strip()
			pf.close()
			if p:
				running = False
				try:
					for i in execute("%s -x opsiconfd" % which("pidof"))[0].strip().split():
						if (i == p):
							running = True
				except Exception, e:
					logger.error(e)
				if running:
					raise Exception("Another opsiconfd process is running (pid: %s), stop process first or change pidfile." % p )
				
	pid = os.getpid()
	pf = open (pidFile, "w")
	print >> pf, str(pid)
	pf.close()
	
	createRoot()
	site = server.Site(root)
	#site = server.Site(log.LogWrapperResource(root))
	#lo = log.BaseCommonAccessLoggingObserver()
	#lo.logMessage = logger.debug
	#lo.start()
	
	sessionHandler = SessionHandler(
				sessionName = sessionName,
				sessionMaxInactiveInterval = sessionMaxInactiveInterval)
	
	if (httpPort > 0):
		if (interface == '0.0.0.0'):
			reactor.listenTCP(httpPort, HTTPFactory(site))
		else:
			reactor.listenTCP(httpPort, HTTPFactory(site), interface = interface)
		
		logger.notice("Accepting HTTP requests on %s:%s" % (interface, httpPort))
	
	if (httpsPort > 0):
		if (interface == '0.0.0.0'):
			reactor.listenSSL(httpsPort, HTTPFactory(site), SSLContext())
		else:
			reactor.listenSSL(httpsPort, HTTPFactory(site), SSLContext(), interface = interface)
		
		logger.notice("Accepting HTTPS requests on %s:%s" % (interface, httpsPort))
	
	reactor.run(installSignalHandlers=0)
	
	wait = True
	while wait:
		wait = False
		for thread in threading.enumerate():
			logger.info("Running thread: %s" % thread)
			if not isinstance(thread, threading._MainThread):
				wait = True
		if wait:
			logger.info("Waiting for running threads to finish up")
			time.sleep(0.2)
	
	sys.exit(0)


if (__name__ == "__main__"):
	
	if (os.name == 'posix'):
		from signal import *
		# Call signalHandler on signal SIGHUP, SIGTERM, SIGINT
		signal(SIGHUP, signalHandler)
		signal(SIGTERM, signalHandler)
		signal(SIGINT, signalHandler)
	
	exception = None
	
	try:
		main(sys.argv[1:])
	
	except SystemExit, e:
		pass
		
	except Exception, e:
		exception = e
	
	try:
		if (pid == os.getpid()):
			logger.info("Removing pid file '%s'" % pidFile)
			os.unlink(pidFile)
	except:
		logger.error("Failed to unlink pid-file '%s'" % pidFile)
	
	if exception:
		logger.logException(exception)
		print >> sys.stderr, "ERROR:", str(exception)
		sys.exit(1)
	sys.exit(0)
	
	
	
	

