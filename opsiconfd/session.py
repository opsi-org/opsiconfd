# -*- coding: utf-8 -*-

# opsiconfd is part of the desktop management solution opsi http://www.opsi.org
# Copyright (c) 2008-2024 uib GmbH <info@uib.de>
# All rights reserved.
# License: AGPL-3.0

"""
session handling
"""

from __future__ import annotations

import asyncio
import base64
import re
import time
import uuid
from collections import namedtuple
from functools import lru_cache
from typing import TYPE_CHECKING, Any, Literal, Optional

import msgspec
import pyotp
from fastapi import FastAPI, HTTPException, status
from fastapi.exceptions import ValidationException
from fastapi.requests import HTTPConnection
from fastapi.responses import (
	JSONResponse,
	PlainTextResponse,
	RedirectResponse,
	Response,
)
from opsicommon.exceptions import (
	OpsiServiceAuthenticationError,
	OpsiServicePermissionError,
)
from opsicommon.logging import secret_filter, set_context
from opsicommon.objects import Host, OpsiClient, User
from opsicommon.types import forceHardwareAddress, forceUUIDString
from opsicommon.utils import ip_address_in_network, timestamp, unix_timestamp
from packaging.version import Version
from redis import ResponseError as RedisResponseError
from starlette.concurrency import run_in_threadpool
from starlette.datastructures import Headers, MutableHeaders
from starlette.types import Message, Receive, Scope, Send

from opsiconfd import contextvar_client_session, server_timing
from opsiconfd.addon import AddonManager
from opsiconfd.application import MaintenanceState
from opsiconfd.application import app as opsiconfd_app
from opsiconfd.auth import AuthenticationMethod, AuthenticationModule
from opsiconfd.auth._pam import PAMAuthentication
from opsiconfd.auth.ldap import LDAPAuthentication
from opsiconfd.auth.user import create_user_roles
from opsiconfd.backend import get_unprotected_backend
from opsiconfd.config import config, opsi_config
from opsiconfd.logging import logger
from opsiconfd.redis import async_redis_client, ip_address_to_redis_key
from opsiconfd.utils import asyncio_create_task
from opsiconfd.utils.modules import check_module

if TYPE_CHECKING:
	from opsiconfd.backend.rpc.main import Backend

# https://github.com/tiangolo/fastapi/blob/master/docs/tutorial/middleware.md
#
# You can add middleware to FastAPI applications.
#
# A "middleware" is a function that works with every request before it is processed by any specific path operation.
# And also with every response before returning it.
#
# 	It takes each request that comes to your application.
# 	It can then do something to that request or run any needed code.
# 	Then it passes the request to be processed by the rest of the application (by some path operation).
# 	It then takes the response generated by the application (by some path operation).
# 	It can do something to that response or run any needed code.
# 	Then it returns the response.

ACCESS_ROLE_PUBLIC = "public"
ACCESS_ROLE_AUTHENTICATED = "authenticated"
ACCESS_ROLE_ADMIN = "admin"
SESSION_COOKIE_NAME = "opsiconfd-session"
SESSION_COOKIE_ATTRIBUTES = ("SameSite=Strict", "Secure")
MESSAGEBUS_IN_USE_TIMEOUT = 60
HARDWARE_ADDRESS_RE = re.compile(r"^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$")
HOST_ID_RE = re.compile(r"^[^.]+\.[^.]+\.\S+$")
# Zsync2 will send "curl/<curl-version>" as User-Agent.
# RedHat / Alma / Rocky package manager will send "libdnf (<os-version>)".
# Do not keep sessions because they will never send a cookie (session id).
# If we keep the session, we may reach the maximum number of sessions per ip.
SESSION_UNAWARE_USER_AGENTS = ("libdnf", "curl")
# Store ip addresses of depots with last access time
depot_addresses: dict[str, float] = {}

session_data_msgpack_encoder = msgspec.msgpack.Encoder()
session_data_msgpack_decoder = msgspec.msgpack.Decoder()

BasicAuth = namedtuple("BasicAuth", ["username", "password"])
AUTH_HEADERS = {"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}


def get_basic_auth(headers: Headers) -> BasicAuth:
	auth_header = headers.get("authorization")

	headers_401 = {}
	if headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
		headers_401 = AUTH_HEADERS

	if not auth_header:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization header missing",
			headers=headers_401,
		)

	if not auth_header.startswith("Basic "):
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization method unsupported",
			headers=headers_401,
		)

	encoded_auth = auth_header[6:]  # Stripping "Basic "
	secret_filter.add_secrets(encoded_auth)
	auth = base64.decodebytes(encoded_auth.encode("ascii")).decode("utf-8")

	if auth.count(":") == 6:
		# Seems to be a mac address as username
		username, password = auth.rsplit(":", 1)
	else:
		username, password = auth.split(":", 1)
	secret_filter.add_secrets(password)

	return BasicAuth(username, password)


class SessionMiddleware:
	def __init__(self, app: FastAPI, public_path: list[str] | None = None) -> None:
		self.app = app
		self._public_path = public_path or []
		self._overload_until = 0.0
		self._websocket_close_errors_ts: list[float] = []

	def set_overload(self, duration: float = 30.0) -> None:
		self._overload_until = time.time() + duration
		logger.warning("Server overload set until %r", self._overload_until)

	def check_overload(self) -> float:
		if self._overload_until <= 0:
			return 0.0
		time_left = self._overload_until - time.time()
		if time_left <= 0:
			self._overload_until = 0.0
			logger.notice("Server overload reset")
			return 0.0
		return time_left

	@staticmethod
	def get_session_id_from_headers(headers: Headers) -> Optional[str]:
		# connection.cookies.get(SESSION_COOKIE_NAME, None)
		# Not working for opsi-script, which sometimes sends:
		# 'NULL; opsiconfd-session=7b9efe97a143438684267dfb71cbace2'
		# Workaround:
		session_cookie_name = SESSION_COOKIE_NAME
		cookies = headers.get("cookie")
		if cookies:
			for cookie in cookies.split(";"):
				cookie_l = cookie.strip().split("=", 1)
				if len(cookie_l) == 2:
					if cookie_l[0].strip().lower() == session_cookie_name:
						return cookie_l[1].strip().lower()
		return None

	async def handle_request(self, connection: HTTPConnection, receive: Receive, send: Send) -> None:
		overload_time_left = self.check_overload()
		if overload_time_left and connection.scope["client"][0] not in ("127.0.0.1", "::1"):
			retry_after = int(overload_time_left)
			raise HTTPException(
				status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
				detail="Server overload",
				headers={"Retry-After": str(retry_after)},
			)
		if isinstance(opsiconfd_app.app_state, MaintenanceState):
			client_in_exceptions = False
			for network in opsiconfd_app.app_state.address_exceptions or []:
				if ip_address_in_network(connection.scope["client"][0], network):
					client_in_exceptions = True
					break
			if not client_in_exceptions:
				raise HTTPException(
					status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
					detail=opsiconfd_app.app_state.message,
					headers={"Retry-After": str(opsiconfd_app.app_state.retry_after)},
				)

		with server_timing("session_handling") as timing:
			scope = connection.scope
			session = scope["session"] = None
			path = scope["path"]
			logger.trace("SessionMiddleware %s", scope)

			await check_network(scope["client"][0])

			if scope["type"] not in ("http", "websocket"):
				await self.app(scope, receive, send)
				return

			# Set default access role
			required_access_role = ACCESS_ROLE_ADMIN
			access_role_public = ACCESS_ROLE_PUBLIC
			if path:
				if path == "/":
					required_access_role = access_role_public
				for pub_path in self._public_path:
					if path.startswith(pub_path):
						required_access_role = access_role_public
						break
			if (
				required_access_role != ACCESS_ROLE_PUBLIC
				and path.startswith(("/rpc", "/monitoring", "/messagebus", "/file-transfer", "/auth"))
				or (path.startswith(("/depot", "/boot")) and scope.get("method") in ("GET", "HEAD", "OPTIONS", "PROPFIND"))
			):
				required_access_role = ACCESS_ROLE_AUTHENTICATED
			scope["required_access_role"] = required_access_role

			# Get session
			session_id = connection.query_params.get("session_id")
			if not session_id:
				session_id = self.get_session_id_from_headers(connection.headers)

			do_auth = required_access_role != ACCESS_ROLE_PUBLIC or connection.headers.get("authorization")
			if session_id or do_auth or path.startswith("/auth"):
				addr = scope["client"]
				session = scope["session"] = await session_manager.get_session(
					client_addr=addr[0], headers=connection.headers, session_id=session_id
				)

			started_authenticated = session and session.authenticated

			# Addon request processing
			if path.startswith("/addons"):
				addon = AddonManager().get_addon_by_path("/".join(path.split("/", 3)[:3]))
				if addon:
					logger.debug("Calling %s.handle_request for path '%s'", addon, path)
					if await addon.handle_request(connection, receive, send):
						return
					# required_access_role and session can be changed by addon
					required_access_role = connection.scope["required_access_role"]
					session = connection.scope["session"]

			if do_auth and (not session or not session.username or not session.authenticated):
				try:
					auth = get_basic_auth(connection.headers)
					await authenticate(connection.scope, auth.username, auth.password)
				except Exception as err:
					if required_access_role != ACCESS_ROLE_PUBLIC:
						raise err

			if required_access_role == ACCESS_ROLE_ADMIN:
				if not session:
					raise OpsiServicePermissionError(f"No admin permissions {scope.get('method')} {scope.get('path')}")

				if not session.is_admin:
					raise OpsiServicePermissionError(f"Not an admin user '{session.username}' {scope.get('method')} {scope.get('path')}")

				if (
					not session.host_id
					and path.startswith("/depot")
					and opsi_config.get("groups", "fileadmingroup") not in session.user_groups
				):
					raise OpsiServicePermissionError(f"Not a file admin user '{scope['session'].username}'")

		if started_authenticated and timing["session_handling"] > 1000:
			logger.warning("Session handling took %0.2fms", timing["session_handling"])

		async def send_wrapper(message: Message) -> None:
			if message["type"] == "http.response.start":
				headers = MutableHeaders(scope=message)
				session = scope["session"]
				if session:
					session.add_session_headers(headers)
				if scope.get("response-headers"):
					for key, value in scope["response-headers"].items():
						headers.append(key, value)
			await send(message)

		await self.app(scope, receive, send_wrapper)

	async def handle_request_exception(self, err: Exception, connection: HTTPConnection, receive: Receive, send: Send) -> None:
		logger.debug("Handle request exception %s: %s", err.__class__.__name__, err, exc_info=True)
		scope = connection.scope
		path = scope["path"]
		if path.startswith("/addons"):
			addon = AddonManager().get_addon_by_path(path)
			if addon:
				logger.debug("Calling %s.handle_request_exception for path '%s'", addon, path)
				if await addon.handle_request_exception(err, connection, receive, send):
					return

		status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
		headers = None
		error = None

		if isinstance(err, (OpsiServiceAuthenticationError, OpsiServicePermissionError)):
			log = logger.warning

			if path:
				if scope.get("method") == "MKCOL" and path.lower().endswith("/system volume information"):
					# Windows WebDAV client is trying to create "System Volume Information"
					log = logger.debug
				elif scope.get("method") == "PROPFIND" and path == "/":
					# Windows WebDAV client PROPFIND /
					log = logger.debug
			log(err)

			status_code = status.HTTP_401_UNAUTHORIZED
			if connection.headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
				headers = AUTH_HEADERS
			error = "Authentication error"
			if isinstance(err, OpsiServicePermissionError):
				error = "Permission denied"

		elif isinstance(err, ConnectionRefusedError):
			error = str(err)
			if "min-configed-version" in error:
				status_code = status.HTTP_426_UPGRADE_REQUIRED
			else:
				status_code = status.HTTP_403_FORBIDDEN

		elif isinstance(err, ValidationException):
			status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
			error = str(err)

		elif isinstance(err, HTTPException):
			status_code = err.status_code
			headers = err.headers
			error = err.detail

		else:
			logger.error(err, exc_info=True)
			error = str(err)

		headers = headers or {}
		headers["x-opsi-error"] = str(error)[:64]

		if scope["type"] == "websocket":
			if connection.headers.get("upgrade") == "websocket":
				# Websocket not opened yet, tested with wsproto only
				await send(
					{
						"type": "websocket.http.response.start",
						"status": status_code,
						"headers": [(k.encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()],
					}
				)
				await send({"type": "websocket.http.response.body", "body": b"ERROR XYZ AAAA"})

			# Uvicorn (0.20.0) always closes websockets with code 403
			# There is currently no way to send a custom status code or headers
			websocket_close_code = status.WS_1008_POLICY_VIOLATION
			reason = error
			if status_code == status.HTTP_500_INTERNAL_SERVER_ERROR:
				websocket_close_code = status.WS_1011_INTERNAL_ERROR
			elif status_code == status.HTTP_503_SERVICE_UNAVAILABLE:
				websocket_close_code = status.WS_1013_TRY_AGAIN_LATER
				reason = f"{reason[:100]}\nRetry-After: {headers.get('Retry-After')}"

			# reason max length 123 bytes
			logger.debug("Closing websocket with code=%r and reason=%r", websocket_close_code, reason)
			try:
				await send({"type": "websocket.close", "code": websocket_close_code, "reason": reason})
			except RuntimeError:
				# Alread closed (can happen on shutdown)
				pass
			return

		if session := scope.get("session"):
			session.add_session_headers(headers)

		response: Optional[Response] = None
		if path.startswith("/rpc"):
			logger.debug("Returning jsonrpc response because path startswith /rpc")
			content = {"id": None, "result": None, "error": error}
			if scope.get("jsonrpc20"):
				content["jsonrpc"] = "2.0"
				del content["result"]
			response = JSONResponse(status_code=status_code, content=content, headers=headers)
		if not response:
			if connection.headers.get("accept") and "application/json" in connection.headers.get("accept", ""):
				logger.debug("Returning json response because of accept header")
				response = JSONResponse(status_code=status_code, content={"error": error}, headers=headers)
		if (
			not response
			and status_code == status.HTTP_401_UNAUTHORIZED
			and path
			and path.lower().split("#", 1)[0].rstrip("/") in ("/admin", "/admin/grafana")
		):
			response = RedirectResponse(f"/login?redirect={scope['path']}", headers=headers)
		if not response:
			logger.debug("Returning plaintext response")
			response = PlainTextResponse(status_code=status_code, content=error, headers=headers)
		await response(scope, receive, send)

	async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
		if scope["type"] == "lifespan":
			return await self.app(scope, receive, send)

		try:
			connection = HTTPConnection(scope)
			set_context({"client_address": scope["client"][0]})
			await self.handle_request(connection, receive, send)
		except Exception as err:
			await self.handle_request_exception(err, connection, receive, send)


class SessionManager:
	def __init__(self, session_check_interval: int = 5, session_store_interval_min: int = 60) -> None:
		self._session_check_interval = session_check_interval
		self._session_store_interval_min = session_store_interval_min
		self._development_option_delay_get_session = "delay-get-session" in config.development_options
		self._manager_task: asyncio.Task | None = None
		self._should_stop = False
		self._stopped = asyncio.Event()
		self.sessions: dict[str, OPSISession] = {}

	def reset(self) -> None:
		self._should_stop = False
		self._stopped = asyncio.Event()
		self.sessions = {}

	async def stop(self, wait: bool = False) -> None:
		self._should_stop = True
		if wait:
			await self._stopped.wait()

	async def manager_task(self) -> None:
		# A session can be managed in multiple worker processes / managers!
		while True:
			try:
				for waits in range(self._session_check_interval):
					# Check for stop and changed _session_check_interval
					if self._should_stop or waits > self._session_check_interval:
						break
					await asyncio.sleep(1)
				if self._should_stop:
					break
				delete_session_ids = []
				for session in list(self.sessions.values()):
					if session.expired:
						version = await session.get_version_from_redis()
						if version == session.version:
							# Not updated by other managers
							logger.debug("Delete expired session: %s", session.session_id)
							await session.delete()
						delete_session_ids.append(session.session_id)
					elif session.deleted:
						logger.debug("Removing deleted session: %s", session.session_id)
						delete_session_ids.append(session.session_id)
					elif not session.last_stored:
						await session.store(modifications_only=False)
					elif session.modifications:
						logger.trace("Session modifications: %s", session.modifications)
						if not set(session.modifications) - {"last_used", "messagebus_last_used"}:
							# Only last_used / messagebus_last_used changed
							if session.authenticated:
								store_interval = min(int(session.max_age / 2), self._session_store_interval_min)
								if time.time() >= session.last_stored + store_interval:
									if await session.is_stored():
										await session.store(modifications_only=True)
									else:
										session.deleted = True
										logger.debug("Session deleted elsewhere: %s", session.session_id)
										delete_session_ids.append(session.session_id)
						else:
							await session.store(modifications_only=True)

				for delete_session_id in delete_session_ids:
					if delete_session_id in self.sessions:
						del self.sessions[delete_session_id]

			except Exception as err:
				logger.error(err, exc_info=True)
		self._stopped.set()

	async def get_session(
		self,
		client_addr: str,
		headers: Headers | None = None,
		session_id: str | None = None,
		create_new: bool = True,
	) -> OPSISession:
		if self._should_stop:
			raise RuntimeError("Shutting down")

		if self._development_option_delay_get_session:
			await asyncio.sleep(3)

		session: OPSISession | None = None
		if session_id:
			session = self.sessions.get(session_id)
			if not session:
				logger.trace("Session not cached, try to load from redis")
				session = OPSISession(client_addr=client_addr, headers=headers, session_id=session_id)
				if await session.load():
					logger.trace("Session loaded from redis")
					self.sessions[session_id] = session
				else:
					logger.trace("Session not found in redis")
					session = None

		if session_id and session:
			refresh_ok = await session.refresh()
			logger.trace(
				"Session refresh: %s - %s - %s - %s",
				refresh_ok,
				session.expired,
				session.client_addr,
				client_addr,
			)
			if refresh_ok and not session.expired:
				if session.client_addr != client_addr:
					logger.debug(
						"Session client address changed from %s to %s",
						session.client_addr,
						client_addr,
					)
					redis = await async_redis_client()
					await redis.sadd(f"{config.redis_key('address_to_session')}:{ip_address_to_redis_key(client_addr)}", session_id)

				await session.update_last_used()
				logger.trace("Session refreshed")
			else:
				logger.trace("Session not valid for refresh")
				if session.expired:
					logger.debug("Session expired, deleting")
					try:
						del self.sessions[session_id]
					except KeyError:
						pass
				session = None

		if session_id and not session and not create_new:
			raise OpsiServiceAuthenticationError("Session not found")

		if not session:
			logger.trace("Creating new session for client %s", client_addr)
			session = OPSISession(client_addr=client_addr, headers=headers)
			await session.init()
			assert session.client_addr == client_addr

			if session.user_agent and session.user_agent.startswith(SESSION_UNAWARE_USER_AGENTS):
				session.persistent = False
				logger.debug("Not keeping session for client %s (%s)", client_addr, session.user_agent)
			else:
				assert session.session_id
				self.sessions[session.session_id] = session

		if headers:
			session.headers = headers

		contextvar_client_session.set(session)

		return session


class OPSISession:
	def __init__(self, client_addr: str, headers: Headers | None = None, session_id: str | None = None) -> None:
		self._headers = Headers()
		self._redis_expiration_seconds = 3600
		self._messagebus_in_use_timeout = MESSAGEBUS_IN_USE_TIMEOUT
		self._modifications: dict[str, float] = {}

		self.password: str | None = None
		self.deleted = False
		self.persistent = True
		self.last_stored = 0
		self.session_id: str | None = session_id or None

		# Attributes to be stored in redis
		self._version: str = ""
		self._client_addr = client_addr
		self._user_agent = ""
		self._max_age = int(config.session_lifetime)
		self._created = 0
		self._last_used = 0
		self._messagebus_last_used = 0
		self._username: str = ""
		self._user_groups: set[str] = set()
		self._host_id: str | None = None
		self._host_type: Literal["OpsiConfigserver", "OpsiDepotserver", "OpsiClient"] | None = None
		self._authenticated = False
		self._auth_methods: set[AuthenticationMethod] = set()
		self._is_admin = False
		self._is_read_only = False

		if headers and isinstance(headers, Headers):
			self.headers = headers

	def __repr__(self) -> str:
		return f"<{self.__class__.__name__} at {hex(id(self))} created={self.created} last_used={self.last_used}>"

	def _set_modified(self, attribute: str) -> None:
		self._modifications[attribute] = unix_timestamp()

	@property
	def modifications(self) -> dict[str, float]:
		return self._modifications

	@property
	def headers(self) -> Headers:
		return self._headers

	@headers.setter
	def headers(self, value: Headers | None) -> None:
		if not value:
			return
		self._headers = value
		self._user_agent = self._headers.get("user-agent") or ""
		x_opsi_session_lifetime = self._headers.get("x-opsi-session-lifetime")
		if x_opsi_session_lifetime:
			try:
				session_lifetime = int(x_opsi_session_lifetime)
				if 0 < session_lifetime <= 3600 * 24:
					if self.max_age != session_lifetime:
						logger.info("Accepting session lifetime %d from client", session_lifetime)
						self.max_age = session_lifetime
				else:
					logger.warning("Not accepting session lifetime %d from client", session_lifetime)
			except ValueError:
				logger.warning("Invalid x-opsi-session-lifetime header with value '%s' from client", x_opsi_session_lifetime)

	@property
	def redis_key(self) -> str:
		assert self.session_id
		return f"{config.redis_key('session')}:{self.session_id}"

	@property
	def expired(self) -> bool:
		return self.validity <= 0

	@property
	def validity(self) -> int:
		return int(self.max_age - (unix_timestamp() - self.last_used))

	@property
	def version(self) -> str | None:
		return self._version

	@version.setter
	def version(self, value: str) -> None:
		if self._version == value:
			return
		self._version = value
		self._set_modified("version")

	@property
	def client_addr(self) -> str:
		return self._client_addr

	@client_addr.setter
	def client_addr(self, value: str) -> None:
		if self._client_addr == value:
			return
		self._client_addr = value
		self._set_modified("client_addr")

	@property
	def user_agent(self) -> str:
		return self._user_agent

	@user_agent.setter
	def user_agent(self, value: str) -> None:
		if self._user_agent == value:
			return
		self._user_agent = value
		self._set_modified("user_agent")

	@property
	def created(self) -> int:
		return self._created

	@created.setter
	def created(self, value: int) -> None:
		value = int(value)
		if self._created == value:
			return
		self._created = value
		self._set_modified("created")

	@property
	def last_used(self) -> int:
		return self._last_used

	@last_used.setter
	def last_used(self, value: int) -> None:
		value = int(value)
		if self._last_used == value:
			return
		self._last_used = value
		self._set_modified("last_used")

	@property
	def messagebus_last_used(self) -> int:
		return self._messagebus_last_used

	@messagebus_last_used.setter
	def messagebus_last_used(self, value: int) -> None:
		value = int(value)
		if self._messagebus_last_used == value:
			return
		self._messagebus_last_used = value
		self._set_modified("messagebus_last_used")

	@property
	def username(self) -> str:
		return self._username

	@username.setter
	def username(self, value: str) -> None:
		if self._username == value:
			return
		self._username = value
		self._set_modified("username")

	@property
	def user_groups(self) -> set[str]:
		return self._user_groups

	@user_groups.setter
	def user_groups(self, value: set[str]) -> None:
		if not isinstance(value, set):
			value = set(value)
		if self._user_groups == value:
			return
		self._user_groups = value
		self._set_modified("user_groups")

	@property
	def host_id(self) -> str | None:
		return self._host_id

	@host_id.setter
	def host_id(self, value: str | None) -> None:
		if self._host_id == value:
			return
		self._host_id = value
		self._set_modified("host_id")

	@property
	def host_type(self) -> str | None:
		return self._host_type

	@host_type.setter
	def host_type(self, value: Literal["OpsiConfigserver", "OpsiDepotserver", "OpsiClient"] | None) -> None:
		if self._host_type == value:
			return
		self._host_type = value
		self._set_modified("host_type")

	@property
	def authenticated(self) -> bool:
		return self._authenticated

	@authenticated.setter
	def authenticated(self, value: bool) -> None:
		value = bool(value)
		if self._authenticated == value:
			return
		self._authenticated = value
		self._set_modified("authenticated")

	@property
	def auth_methods(self) -> set[AuthenticationMethod]:
		return self._auth_methods

	@auth_methods.setter
	def auth_methods(self, value: set[AuthenticationMethod]) -> None:
		if self._auth_methods == value:
			return
		self._auth_methods = value
		self._set_modified("auth_methods")

	def add_auth_methods(self, *value: AuthenticationMethod) -> None:
		for method in value:
			self._auth_methods.add(method)
		self._set_modified("auth_methods")

	@property
	def user_type(self) -> Literal["user", "depot", "client"] | None:
		if not self.authenticated:
			return None
		if not self.host_id:
			return "user"
		if self.host_type in ("OpsiConfigserver", "OpsiDepotserver"):
			return "depot"
		return "client"

	@property
	def is_admin(self) -> bool:
		return self._is_admin

	@is_admin.setter
	def is_admin(self, value: bool) -> None:
		value = bool(value)
		if self._is_admin == value:
			return
		self._is_admin = value
		self._set_modified("is_admin")

	@property
	def is_read_only(self) -> bool:
		return self._is_read_only

	@is_read_only.setter
	def is_read_only(self, value: bool) -> None:
		value = bool(value)
		if self._is_read_only == value:
			return
		self._is_read_only = value
		self._set_modified("is_read_only")

	@property
	def max_age(self) -> int:
		return self._max_age

	@max_age.setter
	def max_age(self, value: int) -> None:
		value = int(value)
		if self._max_age == value:
			return
		self._max_age = value
		self._set_modified("max_age")

	def _reset_auth_data(self) -> None:
		self.username = ""
		self.password = None
		self.user_groups = set()
		self.host_id = None
		self.host_type = None
		self.authenticated = False
		self.auth_methods = set()
		self.is_admin = False
		self.is_read_only = False

	async def init_new_session(self) -> None:
		"""Generate a new session id if number of client sessions is less than max client sessions."""
		self._reset_auth_data()

		max_session_per_ip = config.max_session_per_ip
		if config.max_sessions_excludes and self.client_addr in config.max_sessions_excludes:
			logger.debug("Disable max_session_per_ip for address: %s", self.client_addr)
			max_session_per_ip = 0
		elif self.client_addr in depot_addresses:
			# Connection from a known depot server address
			if time.time() - depot_addresses[self.client_addr] <= config.session_lifetime:
				logger.debug("Disable max_session_per_ip for depot server: %s", self.client_addr)
				max_session_per_ip = 0
			else:
				# Address information is outdated
				del depot_addresses[self.client_addr]

		session_count = 0
		try:
			redis = await async_redis_client()
			now = unix_timestamp()
			ip_key = f"{config.redis_key('address_to_session')}:{ip_address_to_redis_key(self.client_addr)}"
			sids_to_remove = set()
			for sid_b in await redis.smembers(ip_key):
				sid = sid_b.decode("utf-8")
				validity = 0
				try:
					vals = await redis.hmget(f"{config.redis_key('session')}:{sid}", (b"max_age", b"last_used"))
					if vals and vals[0] and vals[1]:
						validity = int(int(vals[0]) - (now - int(vals[1])))
				except Exception as err:
					logger.debug(err)
				if validity > 0:
					session_count += 1
				else:
					sids_to_remove.add(sid)

			if sids_to_remove:
				await redis.srem(ip_key, *sids_to_remove)

			if max_session_per_ip > 0 and session_count + 1 > max_session_per_ip:
				error = f"Too many sessions from {self.client_addr} / {self.user_agent}, maximum is: {max_session_per_ip}"
				logger.warning(error)
				raise ConnectionRefusedError(error)
		except ConnectionRefusedError as err:
			raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(err)) from err

		self.session_id = str(uuid.uuid4()).replace("-", "")
		self.version = str(uuid.uuid4())
		self.created = int(unix_timestamp())
		await redis.sadd(ip_key, self.session_id)
		logger.confidential("Generated a new session id %s for %s / %s", self.session_id, self.client_addr, self.user_agent)

	async def init(self) -> None:
		if self.session_id is None:
			logger.debug("Session id missing (%s / %s)", self.client_addr, self.user_agent)
			await self.init_new_session()
		else:
			if await self.load():
				if self.expired:
					logger.debug("Session expired: %s (%s / %s)", self, self.client_addr, self.user_agent)
					await self.init_new_session()
				else:
					logger.debug("Reusing session: %s (%s / %s)", self, self.client_addr, self.user_agent)
			else:
				logger.debug("Session not found: %s (%s / %s)", self, self.client_addr, self.user_agent)
				await self.init_new_session()
		await self.update_last_used()

	def serialize(self) -> dict[str, float | int | str | bytes]:
		ser = {}
		for attribute in (
			"version",
			"client_addr",
			"user_agent",
			"max_age",
			"created",
			"last_used",
			"messagebus_last_used",
			"username",
			"user_groups",
			"host_id",
			"host_type",
			"authenticated",
			"auth_methods",
			"is_admin",
			"is_read_only",
		):
			val = getattr(self, f"_{attribute}")
			if isinstance(val, set):
				val = msgspec.msgpack.encode(list(val))
			elif isinstance(val, bool):
				val = int(val)
			elif isinstance(val, str):
				val = val.encode("utf-8")
			elif val is None:
				val = b""
			ser[attribute] = val
		return ser

	@classmethod
	def deserialize(cls, data: dict[str | bytes, float | int | bytes | str]) -> dict[str, Any]:
		des: dict[str, Any] = {}
		for attr, val in data.items():
			if isinstance(attr, bytes):
				attr = attr.decode("utf-8")
			if attr == "host":
				# Previously the whole host object was stored
				# So this is for backwards compatibility and can be removed later
				# TODO: Remove
				if val and isinstance(val, bytes):
					host = Host.fromHash(msgspec.msgpack.decode(val))  # type: ignore
					des["host_id"] = host.id
					des["host_type"] = host.getType()
				continue
			elif attr == "user_groups":
				val = set(msgspec.msgpack.decode(val))  # type: ignore
			elif attr == "auth_methods":
				val = set(AuthenticationMethod(v) for v in msgspec.msgpack.decode(val))  # type: ignore
			elif attr in ("authenticated", "is_admin", "is_read_only"):
				val = bool(int(val))
			elif isinstance(val, bytes):
				val = val.decode("utf-8")
			des[attr] = val
		return des

	@classmethod
	def from_serialized(cls, data: dict[str, float | int | bytes | str]) -> OPSISession:
		data = cls.deserialize(data)  # type: ignore
		obj = cls(data["client_addr"])  # type: ignore
		for attr, val in data.items():
			try:
				setattr(obj, attr, val)
			except AttributeError:
				# Ignore unknown attributes from older versions
				pass
		return obj

	def get_cookie(self) -> Optional[str]:
		if not self.session_id or not self.persistent:
			return None
		attrs = "; ".join(SESSION_COOKIE_ATTRIBUTES)
		if attrs:
			attrs += "; "

		# A zero or negative number will expire the cookie immediately
		max_age = f"; Max-Age={self.max_age}"
		if self.deleted:
			max_age = "; Max-Age=0"
		if self.in_use_by_messagebus:
			# Session cookie
			max_age = ""
		return f"{SESSION_COOKIE_NAME}={self.session_id}; {attrs}path=/{max_age}"

	def add_session_headers(self, headers: dict[str, str] | MutableHeaders) -> None:
		cookie = self.get_cookie()
		# Keep current set-cookie header if already set
		if cookie and "set-cookie" not in headers:
			headers["set-cookie"] = cookie
		user_type = self.user_type
		if user_type and self.username:
			headers["X-opsi-user-id"] = f"{user_type}:{self.username}"

	async def update_last_used(self) -> None:
		self.last_used = int(unix_timestamp())

	async def update_messagebus_last_used(self) -> None:
		self.last_used = self.messagebus_last_used = int(unix_timestamp())

	@property
	def in_use_by_messagebus(self) -> bool:
		return int(unix_timestamp()) - self._messagebus_last_used < self._messagebus_in_use_timeout

	async def is_stored(self) -> bool:
		redis = await async_redis_client()
		return bool(await redis.exists(self.redis_key))

	async def get_version_from_redis(self) -> str | None:
		redis = await async_redis_client()
		version = await redis.hget(self.redis_key, b"version")
		if not version:
			return None
		return version.decode("utf-8")

	async def refresh(self) -> bool:
		version = await self.get_version_from_redis()
		if not version:
			# Deleted
			return False
		if version == self.version:
			logger.debug("Version %s unchanged, cache up-to-date", self.version)
			return True
		logger.debug("Version %s changed to %s, reload", self.version, version)
		return await self.load()

	async def load(self) -> bool:
		logger.debug("Load session")
		redis = await async_redis_client()
		data = {}
		try:
			data = self.deserialize(await redis.hgetall(self.redis_key))
		except Exception as err:
			logger.warning("Failed to load session: %s (%s / %s)", err, self.client_addr, self.user_agent)

		if not data:
			return False

		for attr, val in data.items():
			try:
				setattr(self, attr, val)
			except AttributeError:
				pass

		if not self.last_stored:
			self.last_stored = int(unix_timestamp())

		self._modifications = {}
		return True

	async def _store(self, modifications_only: bool = False) -> None:
		if self.deleted or self.expired or not self.persistent:
			return
		if modifications_only and not self._modifications:
			return
		logger.debug("Store session")
		self.version = str(uuid.uuid4())
		self.last_stored = int(unix_timestamp())
		# Remember that the session data in redis may have been
		# changed by another worker process since the last load.
		redis = await async_redis_client()
		data = self.serialize()
		if modifications_only and await redis.exists(self.redis_key):
			data = {a: v for a, v in data.items() if a in self._modifications}
		if data:
			async with redis.pipeline() as pipe:
				pipe.hset(self.redis_key, mapping=data)  # type: ignore
				pipe.expire(self.redis_key, self._redis_expiration_seconds)
				await pipe.execute()

		self._modifications = {}

	async def store(self, wait: bool = True, modifications_only: bool = False) -> None:
		task = self._store(modifications_only)
		if wait:
			await task
		else:
			asyncio_create_task(task)

	async def delete(self) -> None:
		logger.debug("Delete session")
		assert self.session_id
		redis = await async_redis_client()
		async with redis.pipeline(transaction=True) as pipe:
			pipe.delete(self.redis_key)
			pipe.srem(f"{config.redis_key('address_to_session')}:{ip_address_to_redis_key(self.client_addr)}", self.session_id)
			await pipe.execute()
		self.deleted = True


auth_module: AuthenticationModule | None = None


def get_auth_module() -> AuthenticationModule:
	global auth_module

	if not auth_module:
		try:
			ldap_conf = opsi_config.get("ldap_auth")
			if ldap_conf["ldap_url"]:
				logger.debug("Using LDAP auth with config: %s", ldap_conf)
				if "directory-connector" in get_unprotected_backend().available_modules:
					auth_module = LDAPAuthentication(**ldap_conf)
				else:
					logger.error("Disabling LDAP authentication: directory-connector module not available")
		except Exception as err:
			logger.debug(err)

		if not auth_module:
			auth_module = PAMAuthentication()

	return auth_module.get_instance()


def get_peer_cert_common_name(scope: Scope) -> str | None:
	peer_cert = scope.get("extensions", {}).get("peer_cert")
	if not peer_cert:
		return None
	for value in peer_cert["subject"]:
		if value[0][0] == "commonName":
			return value[0][1]
	return None


@lru_cache(maxsize=1)
def vpn_module_available(backend: Backend) -> bool:
	try:
		backend._check_module("vpn")
		return True
	except Exception as err:
		logger.debug(err)
	return False


async def authenticate_host(scope: Scope) -> None:
	session: OPSISession = scope["session"]
	backend = get_unprotected_backend()

	hosts = []
	host_filter = {}
	auth_method = None
	if config.allow_host_key_only_auth:
		session.username = "<host-key-only-auth>"
		logger.debug("Trying to authenticate host by opsi host key only")
		host_filter["opsiHostKey"] = session.password
	elif session.username.startswith("{hardware_address}") or HARDWARE_ADDRESS_RE.search(session.username):
		logger.debug("Trying to authenticate host by mac address and opsi host key")
		host_filter["hardwareAddress"] = forceHardwareAddress(session.username.replace("{hardware_address}", ""))
		auth_method = AuthenticationMethod.HARDWARE_ADDRESS
	elif session.username.startswith("{system_uuid}"):
		logger.debug("Trying to authenticate host by system UUID and opsi host key")
		host_filter["systemUUID"] = forceUUIDString(session.username.replace("{system_uuid}", ""))
		auth_method = AuthenticationMethod.SYSTEM_UUID
	else:
		logger.debug("Trying to authenticate host by host id and opsi host key")
		session.username = session.username.rstrip(".")
		host_filter["id"] = session.username
		auth_method = AuthenticationMethod.HOST_ID

	hosts = await backend.async_call("host_getObjects", **host_filter)
	if not hosts:
		logger.debug("Host not found: %s", session.username)
		if config.recover_clients and "opsiclientd" in session.user_agent:
			logger.debug("Creating host object for host: %s", session.username)
			backend.host_createOpsiClient(
				id=session.username, opsiHostKey=session.password, notes="Created by opsiconfd with recover clients option."
			)
			hosts = await backend.async_call("host_getObjects", **host_filter)
		else:
			raise OpsiServiceAuthenticationError(f"Host not found '{session.username}'")
	if len(hosts) > 1:
		raise OpsiServiceAuthenticationError(f"More than one matching host object found '{session.username}'")
	host = hosts[0]
	if auth_method:
		session.add_auth_methods(auth_method)

	if not host.opsiHostKey:
		raise OpsiServiceAuthenticationError(f"OpsiHostKey missing for host '{host.id}'")

	peer_cert_cn = get_peer_cert_common_name(scope)

	logger.confidential(
		"Host '%s' authentication: password sent '%s', host key '%s', onetime password '%s', client tls certificate CN '%s'",
		host.id,
		session.password,
		host.opsiHostKey,
		host.oneTimePassword if host.getType() == "OpsiClient" else "n.a.",
		peer_cert_cn,
	)

	if ("depot" in config.client_cert_auth and host.getType() in ("OpsiConfigserver", "OpsiDepotserver")) or (
		"client" in config.client_cert_auth and host.getType() == "OpsiClient"
	):
		if vpn_module_available(backend):
			if not peer_cert_cn:
				raise OpsiServiceAuthenticationError(f"Client certificate missing for host '{host.id}'")
			if peer_cert_cn != host.id:
				raise OpsiServiceAuthenticationError(f"Client certificate CN '{peer_cert_cn}' does not match host id '{host.id}'")
			session.add_auth_methods(AuthenticationMethod.TLS_CERTIFICATE)
		else:
			logger.error("VPN module not available, client certificate authentication disabled")

	if host.opsiHostKey and session.password == host.opsiHostKey:
		session.add_auth_methods(AuthenticationMethod.HOST_KEY)
		logger.info("Host '%s' authenticated by host key", host.id)
	elif isinstance(host, OpsiClient) and host.oneTimePassword and session.password == host.oneTimePassword:
		session.add_auth_methods(AuthenticationMethod.PASSWORD_ONETIME)
		logger.info("Host '%s' authenticated by onetime password", host.id)
		host.oneTimePassword = ""
		# Update immediately
		await backend.async_call("host_updateObjectOnAuthenticate", host=host)
	else:
		raise OpsiServiceAuthenticationError(f"Authentication of host '{host.id}' failed")

	host_type = host.getType()
	session.host_id = host.id
	session.host_type = host_type
	session.authenticated = True
	session.is_read_only = False
	session.is_admin = host_type in ("OpsiConfigserver", "OpsiDepotserver")
	if session.username != host.id:
		session.username = host.id
		if not scope.get("response-headers"):
			scope["response-headers"] = {}
		scope["response-headers"]["x-opsi-new-host-id"] = session.username

	if host_type == "OpsiClient":
		logger.info("OpsiClient authenticated, updating host object")
		host.setLastSeen(timestamp())
		if config.update_ip and session.client_addr not in (None, "127.0.0.1", "::1", host.ipAddress):
			host.setIpAddress(session.client_addr)
		else:
			# Value None on update means no change!
			host.ipAddress = None
		await backend.async_call("host_updateObjectOnAuthenticate", host=host)

	elif host_type in ("OpsiConfigserver", "OpsiDepotserver"):
		logger.debug("Storing depot server address: %s", session.client_addr)
		depot_addresses[session.client_addr] = time.time()


async def authenticate_user_passwd(scope: Scope) -> None:
	session: OPSISession = scope["session"]
	backend = get_unprotected_backend()
	credentials = await backend.async_call("user_getCredentials", username=session.username)
	if credentials and session.password == credentials.get("password"):
		session.authenticated = True
		session.is_read_only = True
		session.is_admin = False
		session.add_auth_methods(AuthenticationMethod.USERNAME, AuthenticationMethod.PASSWORD_FILE)
	else:
		raise OpsiServiceAuthenticationError(f"Authentication failed for user {session.username}")


async def authenticate_user_auth_module(scope: Scope) -> AuthenticationModule:
	session: OPSISession = scope["session"]
	authm = get_auth_module()

	if not authm:
		raise OpsiServiceAuthenticationError("Authentication module unavailable")

	peer_cert_cn = get_peer_cert_common_name(scope)

	if "user" in config.client_cert_auth:
		if not peer_cert_cn:
			raise OpsiServiceAuthenticationError(f"Client certificate missing for user '{session.username}'")
		if peer_cert_cn != session.username:
			raise OpsiServiceAuthenticationError(f"Client certificate CN '{peer_cert_cn}' does not match username '{session.username}'")
		session.add_auth_methods(AuthenticationMethod.TLS_CERTIFICATE)

	logger.debug("Trying to authenticate by user authentication module %s", authm)

	try:
		await run_in_threadpool(authm.authenticate, session.username, session.password or "")
		session.add_auth_methods(AuthenticationMethod.USERNAME, authm.authentication_method)
	except Exception as err:
		raise OpsiServiceAuthenticationError(f"Authentication failed for user '{session.username}': {err}") from err

	return authm


async def _post_failed_authenticate(scope: Scope) -> None:
	cmd = (
		f"ts.add {config.redis_key('stats')}:client:failed_auth:{ip_address_to_redis_key(scope['client'][0])} "
		f"* 1 RETENTION 86400000 LABELS client_addr {scope['client'][0]}"
	)
	logger.trace(cmd)
	redis = await async_redis_client()
	await redis.execute_command(cmd)  # type: ignore[no-untyped-call]


async def authenticate(scope: Scope, username: str, password: str, mfa_otp: str | None = None) -> None:
	try:
		await _authenticate(scope, username, password, mfa_otp)
	except OpsiServiceAuthenticationError:
		await _post_failed_authenticate(scope)
		await asyncio.sleep(0.2)
		raise


async def ensure_session(scope: Scope, session_id: str | None = None) -> OPSISession:
	if scope["session"] and (not session_id or scope["session"].session_id == session_id):
		return scope["session"]
	addr = scope["client"]
	scope["session"] = await session_manager.get_session(
		client_addr=addr[0], headers=scope["request_headers"], session_id=session_id, create_new=not session_id
	)
	scope["session"].authenticated = False
	return scope["session"]


async def pre_authenticate(scope: Scope, session_id: str | None = None) -> None:
	await ensure_session(scope, session_id=session_id)
	try:
		await check_min_configed_version(scope["session"].user_agent)
		# Check if client address is blocked
		await check_blocked(scope["session"].client_addr)
	except ConnectionRefusedError as err:
		logger.warning(str(err))
		raise err


async def post_user_authenticate(scope: Scope) -> None:
	session: OPSISession = scope["session"]
	backend = get_unprotected_backend()

	if users := await backend.async_call("user_getObjects", id=session.username):
		users[0].lastLogin = timestamp()
		await backend.async_call("user_updateObject", user=users[0])
	else:
		await backend.async_call("user_insertObject", user=User(id=session.username, created=timestamp(), lastLogin=timestamp()))

	if session.is_admin:
		create_user_roles(session.username, session.user_groups)


async def post_authenticate(scope: Scope) -> None:
	session: OPSISession = scope["session"]

	await session.store(wait=True)

	if not session.username or not session.authenticated:
		raise OpsiServicePermissionError("Not authenticated")

	logger.debug("Client %s authenticated, username: %s", session.client_addr, session.username)

	await check_admin_networks(session)


async def _authenticate(scope: Scope, username: str, password: str, mfa_otp: str | None = None) -> None:
	await pre_authenticate(scope)

	session: OPSISession = scope["session"]

	username = session.username = (username or "").lower()
	password = session.password = password or ""

	logger.info("Start authentication of client %s", session.client_addr)

	if not session.password:
		raise OpsiServiceAuthenticationError("No password specified")

	if session.username == config.monitoring_user:
		if not check_module("monitoring"):
			raise OpsiServicePermissionError("Monitoring module not available. Please check your opsi licenses.")
		await authenticate_user_passwd(scope=scope)
		await post_authenticate(scope)
		return

	if (
		not session.username
		or session.username.startswith("{hardware_address}")
		or session.username.startswith("{system_uuid}")
		or HOST_ID_RE.search(session.username)
		or HARDWARE_ADDRESS_RE.search(session.username)
		or session.username.count(".") >= 2
	):
		await authenticate_host(scope=scope)
		await post_authenticate(scope)
		return

	if config.multi_factor_auth in ("totp_mandatory", "totp_optional"):
		if not mfa_otp:
			mfa_otp = scope["request_headers"].get("x-opsi-mfa-otp")
		if not mfa_otp:
			match = re.search(r"^(.+)(\d{6})$", session.password)
			if match:
				logger.info("Assuming that TOTP is attached to password")
				session.password = match.group(1)
				secret_filter.add_secrets(session.password)
				mfa_otp = match.group(2)

	auth_module = await authenticate_user_auth_module(scope=scope)
	# Authentication did not throw exception => authentication successful

	backend = get_unprotected_backend()
	users = await backend.async_call("user_getObjects", id=session.username)

	if config.multi_factor_auth == "totp_mandatory" or (
		config.multi_factor_auth == "totp_optional" and users and users[0].mfaState == "totp_active"
	):
		if not users or not users[0].otpSecret:
			raise OpsiServiceAuthenticationError("MFA OTP configuration error")
		if not mfa_otp:
			raise OpsiServiceAuthenticationError("MFA one-time password missing")
		totp = pyotp.TOTP(users[0].otpSecret)
		if not totp.verify(mfa_otp):
			raise OpsiServiceAuthenticationError("Incorrect one-time password")
		session.add_auth_methods(AuthenticationMethod.TOTP)
		logger.info("OTP MFA successful")

	session.authenticated = True
	session.user_groups = auth_module.get_groupnames(session.username)
	session.is_admin = auth_module.user_is_admin(session.username)
	session.is_read_only = auth_module.user_is_read_only(session.username)

	logger.info(
		"Authentication successful for user '%s', groups '%s', admin group is '%s', admin: %s, readonly groups %s, readonly: %s",
		session.username,
		",".join(session.user_groups),
		auth_module.get_admin_groupname(),
		session.is_admin,
		auth_module.get_read_only_groupnames(),
		session.is_read_only,
	)

	await post_user_authenticate(scope)
	await post_authenticate(scope)


async def check_admin_networks(session: OPSISession) -> None:
	if not session.is_admin or not config.admin_networks:
		return

	is_admin_network = False
	for network in config.admin_networks:
		if ip_address_in_network(session.client_addr, network):
			is_admin_network = True
			session.add_auth_methods(AuthenticationMethod.ADMIN_NETWORKS)
			break

	if not is_admin_network:
		logger.warning(
			"User '%s' from '%s' not in admin network '%s'",
			session.username,
			session.client_addr,
			config.admin_networks,
		)
		session.is_admin = False
		admin_group = opsi_config.get("groups", "admingroup")
		if admin_group in session.user_groups:
			# Remove admin group from groups because acl.conf currently does not support is_admin
			session.user_groups.remove(admin_group)


async def check_blocked(ip_address: str) -> None:
	logger.info("Checking if client '%s' is blocked", ip_address)
	redis = await async_redis_client()
	ip_key = ip_address_to_redis_key(ip_address)
	is_blocked = bool(await redis.get(f"{config.redis_key('stats')}:client:blocked:{ip_key}"))
	if is_blocked:
		logger.info("Client '%s' is blocked", ip_address)
		raise ConnectionRefusedError(f"Client '{ip_address}' is blocked")

	now = int(unix_timestamp(millis=True))
	cmd = (
		f"ts.range {config.redis_key('stats')}:client:failed_auth:{ip_key} "
		f"{(now-(config.auth_failures_interval*1000))} {now} aggregation count {(config.auth_failures_interval*1000)}"
	)
	logger.debug(cmd)
	try:
		data = await redis.execute_command(cmd)  # type: ignore[no-untyped-call]
		num_failed_auth = int(data[-1][1])
		logger.debug("num_failed_auth: %s", num_failed_auth)
	except RedisResponseError as err:
		num_failed_auth = 0
		if "key does not exist" not in str(err):
			raise
	except IndexError as err:
		logger.debug(err)
		num_failed_auth = 0
	if num_failed_auth >= config.max_auth_failures:
		is_blocked = True
		logger.warning("Blocking client '%s' for %0.2f minutes", ip_address, (config.client_block_time / 60))
		await redis.setex(f"{config.redis_key('stats')}:client:blocked:{ip_key}", config.client_block_time, 1)


async def check_network(client_addr: str) -> None:
	if not config.networks:
		return
	for network in config.networks:
		if ip_address_in_network(client_addr, network):
			return
	raise ConnectionRefusedError(f"Host '{client_addr}' is not allowed to connect")


async def check_min_configed_version(user_agent: str) -> None:
	if not config.min_configed_version or not user_agent or "opsi config editor" not in user_agent:
		return

	configed_version = None
	try:
		configed_version = Version(user_agent.rsplit()[-1])
	except ValueError as err:
		logger.debug(err)

	if not configed_version or configed_version < Version(config.min_configed_version):
		raise ConnectionRefusedError(
			f"Configed {(str(configed_version) if configed_version else user_agent)} "
			f"is not allowed to connect (min-configed-version: {str(config.min_configed_version)})"
		)


session_manager = SessionManager()
