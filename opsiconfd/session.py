# -*- coding: utf-8 -*-

# opsiconfd is part of the desktop management solution opsi http://www.opsi.org
# Copyright (c) 2020-2021 uib GmbH <info@uib.de>
# All rights reserved.
# License: AGPL-3.0
"""
session handling
"""


from __future__ import annotations

import asyncio
import base64
import re
import time
import uuid
from collections import namedtuple
from typing import Any, Optional

import msgspec
import pyotp
from fastapi import FastAPI, HTTPException, status
from fastapi.exceptions import ValidationException
from fastapi.requests import HTTPConnection
from fastapi.responses import (
	JSONResponse,
	PlainTextResponse,
	RedirectResponse,
	Response,
)
from opsicommon.exceptions import (
	BackendAuthenticationError,
	BackendPermissionDeniedError,
)
from opsicommon.logging import secret_filter, set_context
from opsicommon.objects import Host, OpsiClient, User
from opsicommon.utils import ip_address_in_network, timestamp
from opsicommon.types import forceUUIDString, forceHardwareAddress

from packaging.version import Version
from redis import ResponseError as RedisResponseError
from starlette.concurrency import run_in_threadpool
from starlette.datastructures import Headers, MutableHeaders
from starlette.types import Message, Receive, Scope, Send

from opsiconfd import contextvar_client_session, server_timing
from opsiconfd.addon import AddonManager
from opsiconfd.application import MaintenanceState
from opsiconfd.application import app as opsiconfd_app
from opsiconfd.auth import AuthenticationMethod, AuthenticationModule
from opsiconfd.auth.ldap import LDAPAuthentication
from opsiconfd.auth.pam import PAMAuthentication
from opsiconfd.auth.user import create_user_roles
from opsiconfd.backend import (
	get_unprotected_backend,
)
from opsiconfd.config import config, opsi_config
from opsiconfd.logging import logger
from opsiconfd.redis import async_redis_client, ip_address_to_redis_key, redis_client
from opsiconfd.utils import asyncio_create_task, utc_timestamp

# https://github.com/tiangolo/fastapi/blob/master/docs/tutorial/middleware.md
#
# You can add middleware to FastAPI applications.
#
# A "middleware" is a function that works with every request before it is processed by any specific path operation.
# And also with every response before returning it.
#
# 	It takes each request that comes to your application.
# 	It can then do something to that request or run any needed code.
# 	Then it passes the request to be processed by the rest of the application (by some path operation).
# 	It then takes the response generated by the application (by some path operation).
# 	It can do something to that response or run any needed code.
# 	Then it returns the response.

ACCESS_ROLE_PUBLIC = "public"
ACCESS_ROLE_AUTHENTICATED = "authenticated"
ACCESS_ROLE_ADMIN = "admin"
SESSION_COOKIE_NAME = "opsiconfd-session"
SESSION_COOKIE_ATTRIBUTES = ("SameSite=Strict", "Secure")
MESSAGEBUS_IN_USE_TIMEOUT = 60
HARDWARE_ADDRESS_RE = re.compile(r"^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$")
HOST_ID_RE = re.compile(r"^[^.]+\.[^.]+\.\S+$")
# Zsync2 will send "curl/<curl-version>" as User-Agent.
# RedHat / Alma / Rocky package manager will send "libdnf (<os-version>)".
# Do not keep sessions because they will never send a cookie (session id).
# If we keep the session, we may reach the maximum number of sessions per ip.
SESSION_UNAWARE_USER_AGENTS = ("libdnf", "curl")
# Store ip addresses of depots with last access time
depot_addresses: dict[str, float] = {}

session_data_msgpack_encoder = msgspec.msgpack.Encoder()
session_data_msgpack_decoder = msgspec.msgpack.Decoder()

BasicAuth = namedtuple("BasicAuth", ["username", "password"])


def get_basic_auth(headers: Headers) -> BasicAuth:
	auth_header = headers.get("authorization")

	headers_401 = {}
	if headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
		headers_401 = {"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}

	if not auth_header:
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization header missing",
			headers=headers_401,
		)

	if not auth_header.startswith("Basic "):
		raise HTTPException(
			status_code=status.HTTP_401_UNAUTHORIZED,
			detail="Authorization method unsupported",
			headers=headers_401,
		)

	encoded_auth = auth_header[6:]  # Stripping "Basic "
	secret_filter.add_secrets(encoded_auth)
	auth = base64.decodebytes(encoded_auth.encode("ascii")).decode("utf-8")

	if auth.count(":") == 6:
		# Seems to be a mac address as username
		username, password = auth.rsplit(":", 1)
	else:
		username, password = auth.split(":", 1)
	secret_filter.add_secrets(password)

	return BasicAuth(username, password)


class SessionMiddleware:
	def __init__(self, app: FastAPI, public_path: list[str] | None = None) -> None:
		self.app = app
		self._public_path = public_path or []
		self._overload_until = 0.0
		self._websocket_close_errors_ts: list[float] = []

	def set_overload(self, duration: float = 30.0) -> None:
		self._overload_until = time.time() + duration
		logger.warning("Server overload set until %r", self._overload_until)

	def check_overload(self) -> float:
		if self._overload_until <= 0:
			return 0.0
		time_left = self._overload_until - time.time()
		if time_left <= 0:
			self._overload_until = 0.0
			logger.notice("Server overload reset")
			return 0.0
		return time_left

	@staticmethod
	def get_session_id_from_headers(headers: Headers) -> Optional[str]:
		# connection.cookies.get(SESSION_COOKIE_NAME, None)
		# Not working for opsi-script, which sometimes sends:
		# 'NULL; opsiconfd-session=7b9efe97a143438684267dfb71cbace2'
		# Workaround:
		session_cookie_name = SESSION_COOKIE_NAME
		cookies = headers.get("cookie")
		if cookies:
			for cookie in cookies.split(";"):
				cookie_l = cookie.strip().split("=", 1)
				if len(cookie_l) == 2:
					if cookie_l[0].strip().lower() == session_cookie_name:
						return cookie_l[1].strip().lower()
		return None

	async def handle_request(self, connection: HTTPConnection, receive: Receive, send: Send) -> None:
		overload_time_left = self.check_overload()
		if overload_time_left and connection.scope["client"][0] not in ("127.0.0.1", "::1"):
			retry_after = int(overload_time_left)
			raise HTTPException(
				status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
				detail="Server overload",
				headers={"Retry-After": str(retry_after)},
			)
		if isinstance(opsiconfd_app.app_state, MaintenanceState):
			client_in_exceptions = False
			for network in opsiconfd_app.app_state.address_exceptions or []:
				if ip_address_in_network(connection.scope["client"][0], network):
					client_in_exceptions = True
					break
			if not client_in_exceptions:
				raise HTTPException(
					status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
					detail=opsiconfd_app.app_state.message,
					headers={"Retry-After": str(opsiconfd_app.app_state.retry_after)},
				)

		with server_timing("session_handling") as timing:
			scope = connection.scope
			scope["session"] = None
			logger.trace("SessionMiddleware %s", scope)

			await check_network(scope["client"][0])

			if scope["type"] not in ("http", "websocket"):
				await self.app(scope, receive, send)
				return

			# Set default access role
			required_access_role = ACCESS_ROLE_ADMIN
			access_role_public = ACCESS_ROLE_PUBLIC
			if scope["full_path"]:
				if scope["full_path"] == "/":
					required_access_role = access_role_public
				for pub_path in self._public_path:
					if scope["full_path"].startswith(pub_path):
						required_access_role = access_role_public
						break
			scope["required_access_role"] = required_access_role

			if scope["full_path"].startswith(("/rpc", "/monitoring", "/messagebus", "/file-transfer")) or (
				scope["full_path"].startswith(("/depot", "/boot")) and scope.get("method") in ("GET", "HEAD", "OPTIONS", "PROPFIND")
			):
				scope["required_access_role"] = ACCESS_ROLE_AUTHENTICATED

			# Get session
			session_id = self.get_session_id_from_headers(connection.headers)
			if scope["required_access_role"] != ACCESS_ROLE_PUBLIC or session_id:
				addr = scope["client"]
				scope["session"] = await session_manager.get_session(client_addr=addr[0], headers=connection.headers, session_id=session_id)

			started_authenticated = scope["session"] and scope["session"].authenticated

			# Addon request processing
			if scope["full_path"].startswith("/addons"):
				addon = AddonManager().get_addon_by_path("/".join(scope["full_path"].split("/", 3)[:3]))
				if addon:
					logger.debug("Calling %s.handle_request for path '%s'", addon, scope["full_path"])
					if await addon.handle_request(connection, receive, send):
						return

			await check_access(connection)
			if (
				scope["session"]
				and required_access_role == ACCESS_ROLE_ADMIN
				and not scope["session"].host
				and scope["full_path"].startswith("/depot")
				and opsi_config.get("groups", "fileadmingroup") not in scope["session"].user_groups
			):
				raise BackendPermissionDeniedError(f"Not a file admin user '{scope['session'].username}'")

		if started_authenticated and timing["session_handling"] > 1000:
			logger.warning("Session handling took %0.2fms", timing["session_handling"])

		async def send_wrapper(message: Message) -> None:
			if message["type"] == "http.response.start":
				headers = MutableHeaders(scope=message)
				if scope["session"]:
					scope["session"].add_cookie_to_headers(headers)
				if scope.get("response-headers"):
					for key, value in scope["response-headers"].items():
						headers.append(key, value)
			await send(message)

		await self.app(scope, receive, send_wrapper)

	async def handle_request_exception(self, err: Exception, connection: HTTPConnection, receive: Receive, send: Send) -> None:
		logger.debug("Handle request exception %s: %s", err.__class__.__name__, err, exc_info=True)
		scope = connection.scope
		if scope["full_path"].startswith("/addons"):
			addon = AddonManager().get_addon_by_path(scope["full_path"])
			if addon:
				logger.debug("Calling %s.handle_request_exception for path '%s'", addon, scope["full_path"])
				if await addon.handle_request_exception(err, connection, receive, send):
					return

		status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
		headers = None
		error = None

		if isinstance(err, (BackendAuthenticationError, BackendPermissionDeniedError)):
			log = logger.warning

			if scope["path"]:
				if scope.get("method") == "MKCOL" and scope["path"].lower().endswith("/system volume information"):
					# Windows WebDAV client is trying to create "System Volume Information"
					log = logger.debug
				elif scope.get("method") == "PROPFIND" and scope["path"] == "/":
					# Windows WebDAV client PROPFIND /
					log = logger.debug
			log(err)

			status_code = status.HTTP_401_UNAUTHORIZED
			if connection.headers.get("X-Requested-With", "").lower() != "xmlhttprequest":
				headers = {"WWW-Authenticate": 'Basic realm="opsi", charset="UTF-8"'}
			error = "Authentication error"
			if isinstance(err, BackendPermissionDeniedError):
				error = "Permission denied"

		elif isinstance(err, ConnectionRefusedError):
			status_code = status.HTTP_403_FORBIDDEN
			error = str(err)

		elif isinstance(err, ValidationException):
			status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
			error = str(err)

		elif isinstance(err, HTTPException):
			status_code = err.status_code
			headers = err.headers
			error = err.detail

		else:
			logger.error(err, exc_info=True)
			error = str(err)

		headers = headers or {}
		headers["x-opsi-error"] = str(error)[:64]

		if scope["type"] == "websocket":
			if connection.headers.get("upgrade") == "websocket":
				# Websocket not opened yet, tested with wsproto only
				await send(
					{
						"type": "websocket.http.response.start",
						"status": status_code,
						"headers": [(k.encode("latin-1"), v.encode("latin-1")) for k, v in headers.items()],
					}
				)
				await send({"type": "websocket.http.response.body", "body": b"ERROR XYZ AAAA"})

			# Uvicorn (0.20.0) always closes websockets with code 403
			# There is currently no way to send a custom status code or headers
			websocket_close_code = status.WS_1008_POLICY_VIOLATION
			reason = error
			if status_code == status.HTTP_500_INTERNAL_SERVER_ERROR:
				websocket_close_code = status.WS_1011_INTERNAL_ERROR
			elif status_code == status.HTTP_503_SERVICE_UNAVAILABLE:
				websocket_close_code = status.WS_1013_TRY_AGAIN_LATER
				reason = f"{reason[:100]}\nRetry-After: {headers.get('Retry-After')}"

			# reason max length 123 bytes
			logger.debug("Closing websocket with code=%r and reason=%r", websocket_close_code, reason)
			try:
				await send({"type": "websocket.close", "code": websocket_close_code, "reason": reason})
			except RuntimeError:
				# Alread closed (can happen on shutdown)
				pass
			return

		if scope.get("session"):
			scope["session"].add_cookie_to_headers(headers)

		response: Optional[Response] = None
		if scope["full_path"].startswith("/rpc"):
			logger.debug("Returning jsonrpc response because path startswith /rpc")
			content = {"id": None, "result": None, "error": error}
			if scope.get("jsonrpc20"):
				content["jsonrpc"] = "2.0"
				del content["result"]
			response = JSONResponse(status_code=status_code, content=content, headers=headers)
		if not response:
			if connection.headers.get("accept") and "application/json" in connection.headers.get("accept", ""):
				logger.debug("Returning json response because of accept header")
				response = JSONResponse(status_code=status_code, content={"error": error}, headers=headers)
		if (
			not response
			and status_code == status.HTTP_401_UNAUTHORIZED
			and scope["full_path"]
			and scope["full_path"].lower().split("#", 1)[0].rstrip("/") in ("/admin", "/admin/grafana")
		):
			response = RedirectResponse(f"/login?redirect={scope['full_path']}", headers=headers)
		if not response:
			logger.debug("Returning plaintext response")
			response = PlainTextResponse(status_code=status_code, content=error, headers=headers)
		await response(scope, receive, send)

	async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
		if scope["type"] == "lifespan":
			return await self.app(scope, receive, send)

		try:
			connection = HTTPConnection(scope)
			set_context({"client_address": scope["client"][0]})
			await self.handle_request(connection, receive, send)
		except Exception as err:
			await self.handle_request_exception(err, connection, receive, send)


class SessionManager:
	def __init__(self, session_check_interval: int = 5, session_store_interval_min: int = 60) -> None:
		self._session_check_interval = session_check_interval
		self._session_store_interval_min = session_store_interval_min
		self._development_option_delay_get_session = "delay-get-session" in config.development_options
		self._manager_task: asyncio.Task | None = None
		self._should_stop = False
		self._stopped = asyncio.Event()
		self.sessions: dict[str, OPSISession] = {}

	def reset(self) -> None:
		self._should_stop = False
		self._stopped = asyncio.Event()
		self.sessions = {}

	async def stop(self, wait: bool = False) -> None:
		self._should_stop = True
		if wait:
			await self._stopped.wait()

	async def manager_task(self) -> None:
		# A session can be managed in multiple worker processes / managers!
		while True:
			try:
				for waits in range(self._session_check_interval):
					# Check for stop and changed _session_check_interval
					if self._should_stop or waits > self._session_check_interval:
						break
					await asyncio.sleep(1)
				if self._should_stop:
					break
				delete_session_ids = []
				for session in list(self.sessions.values()):
					if session.expired:
						version = await session.get_version_from_redis()
						if version == session.version:
							# Not updated by other managers
							logger.debug("Delete expired session: %s", session.session_id)
							await session.delete()
						delete_session_ids.append(session.session_id)
					elif session.deleted:
						logger.debug("Removing deleted session: %s", session.session_id)
						delete_session_ids.append(session.session_id)
					elif not session.last_stored:
						await session.store(modifications_only=False)
					elif session.modifications:
						logger.trace("Session modifications: %s", session.modifications)
						if not set(session.modifications) - {"last_used", "messagebus_last_used"}:
							# Only last_used / messagebus_last_used changed
							if session.authenticated:
								store_interval = min(int(session.max_age / 2), self._session_store_interval_min)
								if time.time() >= session.last_stored + store_interval:
									if await session.is_stored():
										await session.store(modifications_only=True)
									else:
										session.deleted = True
										logger.debug("Session deleted elsewhere: %s", session.session_id)
										delete_session_ids.append(session.session_id)
						else:
							await session.store(modifications_only=True)

				for delete_session_id in delete_session_ids:
					if delete_session_id in self.sessions:
						del self.sessions[delete_session_id]

			except Exception as err:
				logger.error(err, exc_info=True)
		self._stopped.set()

	async def get_session(self, client_addr: str, headers: Headers | None = None, session_id: str | None = None) -> OPSISession:
		if self._should_stop:
			raise RuntimeError("Shutting down")

		if self._development_option_delay_get_session:
			await asyncio.sleep(3)

		session: OPSISession | None = None
		if session_id:
			session = self.sessions.get(session_id)

		if session_id and session:
			refresh_ok = await session.refresh()
			if refresh_ok and not session.expired and session.client_addr == client_addr:
				await session.update_last_used()
			else:
				try:
					del self.sessions[session_id]
				except KeyError:
					pass
				session_id = None
				session = None

		if not session:
			session = OPSISession(client_addr=client_addr, headers=headers, session_id=session_id)
			await session.init()
			assert session.client_addr == client_addr

			if session.user_agent and session.user_agent.startswith(SESSION_UNAWARE_USER_AGENTS):
				session.persistent = False
				logger.debug("Not keeping session for client %s (%s)", client_addr, session.user_agent)
			else:
				assert session.session_id
				self.sessions[session.session_id] = session

		if headers:
			session.headers = headers

		contextvar_client_session.set(session)

		return session


class OPSISession:
	def __init__(self, client_addr: str, headers: Headers | None = None, session_id: str | None = None) -> None:
		self._headers = Headers()
		self._redis_expiration_seconds = 3600
		self._messagebus_in_use_timeout = MESSAGEBUS_IN_USE_TIMEOUT
		self._modifications: dict[str, float] = {}

		self.password: str | None = None
		self.deleted = False
		self.persistent = True
		self.last_stored = 0
		self.session_id: str | None = session_id or None

		# Attributes to be stored in redis
		self._version: str = ""
		self._client_addr = client_addr
		self._user_agent = ""
		self._max_age = int(config.session_lifetime)
		self._created = 0
		self._last_used = 0
		self._messagebus_last_used = 0
		self._username: str = ""
		self._user_groups: set[str] = set()
		self._host: Host | None = None
		self._authenticated = False
		self._auth_methods: set[AuthenticationMethod] = set()
		self._is_admin = False
		self._is_read_only = False

		if headers and isinstance(headers, Headers):
			self.headers = headers

	def __repr__(self) -> str:
		return f"<{self.__class__.__name__} at {hex(id(self))} created={self.created} last_used={self.last_used}>"

	def _set_modified(self, attribute: str) -> None:
		self._modifications[attribute] = utc_timestamp()

	@property
	def modifications(self) -> dict[str, float]:
		return self._modifications

	@property
	def headers(self) -> Headers:
		return self._headers

	@headers.setter
	def headers(self, value: Headers | None) -> None:
		if not value:
			return
		self._headers = value
		self._user_agent = self._headers.get("user-agent") or ""
		x_opsi_session_lifetime = self._headers.get("x-opsi-session-lifetime")
		if x_opsi_session_lifetime:
			try:
				session_lifetime = int(x_opsi_session_lifetime)
				if 0 < session_lifetime <= 3600 * 24:
					logger.info("Accepting session lifetime %d from client", session_lifetime)
					self.max_age = session_lifetime
				else:
					logger.warning("Not accepting session lifetime %d from client", session_lifetime)
			except ValueError:
				logger.warning("Invalid x-opsi-session-lifetime header with value '%s' from client", x_opsi_session_lifetime)

	@property
	def redis_key(self) -> str:
		assert self.session_id
		return f"{config.redis_key('session')}:{ip_address_to_redis_key(self.client_addr)}:{self.session_id}"

	@property
	def expired(self) -> bool:
		return self.validity <= 0

	@property
	def validity(self) -> int:
		return int(self.max_age - (utc_timestamp() - self.last_used))

	@property
	def version(self) -> str | None:
		return self._version

	@version.setter
	def version(self, value: str) -> None:
		if self._version == value:
			return
		self._version = value
		self._set_modified("version")

	@property
	def client_addr(self) -> str:
		return self._client_addr

	@client_addr.setter
	def client_addr(self, value: str) -> None:
		if self._client_addr == value:
			return
		self._client_addr = value
		self._set_modified("client_addr")

	@property
	def user_agent(self) -> str:
		return self._user_agent

	@user_agent.setter
	def user_agent(self, value: str) -> None:
		if self._user_agent == value:
			return
		self._user_agent = value
		self._set_modified("user_agent")

	@property
	def created(self) -> int:
		return self._created

	@created.setter
	def created(self, value: int) -> None:
		value = int(value)
		if self._created == value:
			return
		self._created = value
		self._set_modified("created")

	@property
	def last_used(self) -> int:
		return self._last_used

	@last_used.setter
	def last_used(self, value: int) -> None:
		value = int(value)
		if self._last_used == value:
			return
		self._last_used = value
		self._set_modified("last_used")

	@property
	def messagebus_last_used(self) -> int:
		return self._messagebus_last_used

	@messagebus_last_used.setter
	def messagebus_last_used(self, value: int) -> None:
		value = int(value)
		if self._messagebus_last_used == value:
			return
		self._messagebus_last_used = value
		self._set_modified("messagebus_last_used")

	@property
	def username(self) -> str:
		return self._username

	@username.setter
	def username(self, value: str) -> None:
		if self._username == value:
			return
		self._username = value
		self._set_modified("username")

	@property
	def user_groups(self) -> set[str]:
		return self._user_groups

	@user_groups.setter
	def user_groups(self, value: set[str]) -> None:
		if self._user_groups == value:
			return
		self._user_groups = value
		self._set_modified("user_groups")

	@property
	def host(self) -> Host | None:
		return self._host

	@host.setter
	def host(self, value: Host | None) -> None:
		if self._host == value:
			return
		self._host = value
		self._set_modified("host")

	@property
	def authenticated(self) -> bool:
		return self._authenticated

	@authenticated.setter
	def authenticated(self, value: bool) -> None:
		value = bool(value)
		if self._authenticated == value:
			return
		self._authenticated = value
		self._set_modified("authenticated")

	@property
	def auth_methods(self) -> set[AuthenticationMethod]:
		return self._auth_methods

	@auth_methods.setter
	def auth_methods(self, value: set[AuthenticationMethod]) -> None:
		if self._auth_methods == value:
			return
		self._auth_methods = value
		self._set_modified("auth_methods")

	def add_auth_methods(self, *value: AuthenticationMethod) -> None:
		for method in value:
			self._auth_methods.add(method)
		self._set_modified("auth_methods")

	@property
	def is_admin(self) -> bool:
		return self._is_admin

	@is_admin.setter
	def is_admin(self, value: bool) -> None:
		value = bool(value)
		if self._is_admin == value:
			return
		self._is_admin = value
		self._set_modified("is_admin")

	@property
	def is_read_only(self) -> bool:
		return self._is_read_only

	@is_read_only.setter
	def is_read_only(self, value: bool) -> None:
		value = bool(value)
		if self._is_read_only == value:
			return
		self._is_read_only = value
		self._set_modified("is_read_only")

	@property
	def max_age(self) -> int:
		return self._max_age

	@max_age.setter
	def max_age(self, value: int) -> None:
		value = int(value)
		if self._max_age == value:
			return
		self._max_age = value
		self._set_modified("max_age")

	def _reset_auth_data(self) -> None:
		self.username = ""
		self.password = None
		self.user_groups = set()
		self.host = None
		self.authenticated = False
		self.auth_methods = set()
		self.is_admin = False
		self.is_read_only = False

	async def init_new_session(self) -> None:
		"""Generate a new session id if number of client sessions is less than max client sessions."""
		self._reset_auth_data()

		max_session_per_ip = config.max_session_per_ip
		if config.max_sessions_excludes and self.client_addr in config.max_sessions_excludes:
			logger.debug("Disable max_session_per_ip for address: %s", self.client_addr)
			max_session_per_ip = 0
		elif self.client_addr in depot_addresses:
			# Connection from a known depot server address
			if time.time() - depot_addresses[self.client_addr] <= config.session_lifetime:
				logger.debug("Disable max_session_per_ip for depot server: %s", self.client_addr)
				max_session_per_ip = 0
			else:
				# Address information is outdated
				del depot_addresses[self.client_addr]

		session_count = 0
		try:
			redis = await async_redis_client()
			now = utc_timestamp()
			session_key = f"{config.redis_key('session')}:{ip_address_to_redis_key(self.client_addr)}:*"
			async for redis_key in redis.scan_iter(session_key):
				validity = 0
				try:
					vals = await redis.hmget(redis_key, (b"max_age", b"last_used"))
					if vals and vals[0] and vals[1]:
						validity = int(int(vals[0]) - (now - int(vals[1])))
				except Exception as err:
					logger.debug(err)
				if validity > 0:
					session_count += 1
				else:
					await redis.delete(redis_key)

			if max_session_per_ip > 0 and session_count + 1 > max_session_per_ip:
				error = f"Too many sessions from {self.client_addr} / {self.user_agent}, maximum is: {max_session_per_ip}"
				logger.warning(error)
				raise ConnectionRefusedError(error)
		except ConnectionRefusedError as err:
			raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(err)) from err

		self.session_id = str(uuid.uuid4()).replace("-", "")
		self.version = str(uuid.uuid4())
		self.created = int(utc_timestamp())
		logger.confidential("Generated a new session id %s for %s / %s", self.session_id, self.client_addr, self.user_agent)

	async def init(self) -> None:
		if self.session_id is None:
			logger.debug("Session id missing (%s / %s)", self.client_addr, self.user_agent)
			await self.init_new_session()
		else:
			if await self.load():
				if self.expired:
					logger.debug("Session expired: %s (%s / %s)", self, self.client_addr, self.user_agent)
					await self.init_new_session()
				else:
					logger.debug("Reusing session: %s (%s / %s)", self, self.client_addr, self.user_agent)
			else:
				logger.debug("Session not found: %s (%s / %s)", self, self.client_addr, self.user_agent)
				await self.init_new_session()
		await self.update_last_used()

	def serialize(self) -> dict[str, float | int | str | bytes]:
		ser = {}
		for attribute in (
			"version",
			"client_addr",
			"user_agent",
			"max_age",
			"created",
			"last_used",
			"messagebus_last_used",
			"username",
			"user_groups",
			"host",
			"authenticated",
			"auth_methods",
			"is_admin",
			"is_read_only",
		):
			val = getattr(self, f"_{attribute}")
			if isinstance(val, Host):
				val = msgspec.msgpack.encode(val.to_hash())
			elif isinstance(val, set):
				val = msgspec.msgpack.encode(list(val))
			elif isinstance(val, bool):
				val = int(val)
			elif isinstance(val, str):
				val = val.encode("utf-8")
			elif val is None:
				val = b""
			ser[attribute] = val
		return ser

	@classmethod
	def deserialize(cls, data: dict[str | bytes, float | int | bytes | str]) -> dict[str, Any]:
		des = {}
		for attr, val in data.items():
			if isinstance(attr, bytes):
				attr = attr.decode("utf-8")
			if attr == "host":
				if val:
					assert isinstance(val, bytes)
					val = Host.fromHash(msgspec.msgpack.decode(val))  # type: ignore
				else:
					val = None  # type: ignore
			elif attr == "user_groups":
				val = set(msgspec.msgpack.decode(val))  # type: ignore
			elif attr == "auth_methods":
				val = set(AuthenticationMethod(v) for v in msgspec.msgpack.decode(val))  # type: ignore
			elif attr in ("authenticated", "is_admin", "is_read_only"):
				val = bool(int(val))
			elif isinstance(val, bytes):
				val = val.decode("utf-8")
			des[attr] = val
		return des

	@classmethod
	def from_serialized(cls, data: dict[str, float | int | bytes | str]) -> OPSISession:
		data = cls.deserialize(data)  # type: ignore
		obj = cls(data["client_addr"])  # type: ignore
		for attr, val in data.items():
			setattr(obj, attr, val)
		return obj

	def get_cookie(self) -> Optional[str]:
		if not self.session_id or not self.persistent:
			return None
		attrs = "; ".join(SESSION_COOKIE_ATTRIBUTES)
		if attrs:
			attrs += "; "

		# A zero or negative number will expire the cookie immediately
		max_age = f"; Max-Age={self.max_age}"
		if self.deleted:
			max_age = "; Max-Age=0"
		if self.in_use_by_messagebus:
			# Session cookie
			max_age = ""
		return f"{SESSION_COOKIE_NAME}={self.session_id}; {attrs}path=/{max_age}"

	def add_cookie_to_headers(self, headers: dict[str, str]) -> None:
		cookie = self.get_cookie()
		# Keep current set-cookie header if already set
		if cookie and "set-cookie" not in headers:
			headers["set-cookie"] = cookie

	async def update_last_used(self) -> None:
		self.last_used = int(utc_timestamp())

	async def update_messagebus_last_used(self) -> None:
		self.last_used = self.messagebus_last_used = int(utc_timestamp())

	@property
	def in_use_by_messagebus(self) -> bool:
		return int(utc_timestamp()) - self._messagebus_last_used < self._messagebus_in_use_timeout

	async def is_stored(self) -> bool:
		redis = await async_redis_client()
		return bool(await redis.exists(self.redis_key))

	async def get_version_from_redis(self) -> str | None:
		redis = await async_redis_client()
		version = await redis.hget(self.redis_key, b"version")
		if not version:
			return None
		return version.decode("utf-8")

	async def refresh(self) -> bool:
		version = await self.get_version_from_redis()
		if not version:
			# Deleted
			return False
		if version == self.version:
			logger.debug("Version %s unchanged, cache up-to-date", self.version)
			return True
		logger.debug("Version %s changed to %s, reload", self.version, version)
		return await self.load()

	async def load(self) -> bool:
		logger.debug("Load session")
		redis = await async_redis_client()
		data = {}
		try:
			data = self.deserialize(await redis.hgetall(self.redis_key))
		except Exception as err:
			logger.warning("Failed to load session: %s (%s / %s)", err, self.client_addr, self.user_agent)

		if not data:
			return False

		for attr, val in data.items():
			try:
				setattr(self, attr, val)
			except AttributeError:
				pass

		if not self.last_stored:
			self.last_stored = int(utc_timestamp())

		self._modifications = {}
		return True

	async def _store(self, modifications_only: bool = False) -> None:
		if self.deleted or self.expired or not self.persistent:
			return
		if modifications_only and not self._modifications:
			return
		logger.debug("Store session")
		self.version = str(uuid.uuid4())
		self.last_stored = int(utc_timestamp())
		# Remember that the session data in redis may have been
		# changed by another worker process since the last load.
		redis = await async_redis_client()
		data = self.serialize()
		if modifications_only and await redis.exists(self.redis_key):
			data = {a: v for a, v in data.items() if a in self._modifications}
		if data:
			async with redis.pipeline() as pipe:
				pipe.hset(self.redis_key, mapping=data)  # type: ignore
				pipe.expire(self.redis_key, self._redis_expiration_seconds)
				await pipe.execute()

		self._modifications = {}

	async def store(self, wait: bool = True, modifications_only: bool = False) -> None:
		task = self._store(modifications_only)
		if wait:
			await task
		else:
			asyncio_create_task(task)

	async def delete(self) -> None:
		logger.debug("Delete session")
		redis = await async_redis_client()
		for _ in range(10):
			await redis.delete(self.redis_key)
			await asyncio.sleep(0.01)
			# Be sure to delete key
			if not await redis.exists(self.redis_key):
				break
		self.deleted = True

	def sync_delete(self) -> None:
		redis = redis_client()
		for _ in range(10):
			redis.delete(self.redis_key)
			time.sleep(0.01)
			# Be sure to delete key
			if not redis.exists(self.redis_key):
				break
		self.deleted = True


auth_module: AuthenticationModule | None = None


def get_auth_module() -> AuthenticationModule:
	global auth_module

	if not auth_module:
		try:
			ldap_conf = opsi_config.get("ldap_auth")
			if ldap_conf["ldap_url"]:
				logger.debug("Using LDAP auth with config: %s", ldap_conf)
				if "directory-connector" in get_unprotected_backend().available_modules:
					auth_module = LDAPAuthentication(**ldap_conf)
				else:
					logger.error("Disabling LDAP authentication: directory-connector module not available")
		except Exception as err:
			logger.debug(err)

		if not auth_module:
			auth_module = PAMAuthentication()

	return auth_module.get_instance()


def get_peer_cert_common_name(scope: Scope) -> str | None:
	peer_cert = scope.get("extensions", {}).get("peer_cert")
	if not peer_cert:
		return None
	for value in peer_cert["subject"]:
		if value[0][0] == "commonName":
			return value[0][1]
	return None


async def authenticate_host(scope: Scope) -> None:
	session: OPSISession = scope["session"]
	backend = get_unprotected_backend()

	hosts = []
	host_filter = {}
	auth_method = None
	if config.allow_host_key_only_auth:
		session.username = "<host-key-only-auth>"
		logger.debug("Trying to authenticate host by opsi host key only")
		host_filter["opsiHostKey"] = session.password
	elif session.username.startswith("{hardware_address}") or HARDWARE_ADDRESS_RE.search(session.username):
		logger.debug("Trying to authenticate host by mac address and opsi host key")
		host_filter["hardwareAddress"] = forceHardwareAddress(session.username.replace("{hardware_address}", ""))
		auth_method = AuthenticationMethod.HARDWARE_ADDRESS
	elif session.username.startswith("{system_uuid}"):
		logger.debug("Trying to authenticate host by system UUID and opsi host key")
		host_filter["systemUUID"] = forceUUIDString(session.username.replace("{system_uuid}", ""))
		auth_method = AuthenticationMethod.SYSTEM_UUID
	else:
		logger.debug("Trying to authenticate host by host id and opsi host key")
		session.username = session.username.rstrip(".")
		host_filter["id"] = session.username
		auth_method = AuthenticationMethod.HOST_ID

	hosts = await backend.async_call("host_getObjects", **host_filter)
	if not hosts:
		raise BackendAuthenticationError(f"Host not found '{session.username}'")
	if len(hosts) > 1:
		raise BackendAuthenticationError(f"More than one matching host object found '{session.username}'")
	host = hosts[0]
	if auth_method:
		session.add_auth_methods(auth_method)

	if not host.opsiHostKey:
		raise BackendAuthenticationError(f"OpsiHostKey missing for host '{host.id}'")

	peer_cert_cn = get_peer_cert_common_name(scope)

	logger.confidential(
		"Host '%s' authentication: password sent '%s', host key '%s', onetime password '%s', client tls certificate CN '%s'",
		host.id,
		session.password,
		host.opsiHostKey,
		host.oneTimePassword if host.getType() == "OpsiClient" else "n.a.",
		peer_cert_cn,
	)

	if ("depot" in config.client_cert_auth and host.getType() in ("OpsiConfigserver", "OpsiDepotserver")) or (
		"client" in config.client_cert_auth and host.getType() == "OpsiClient"
	):
		if not peer_cert_cn:
			raise BackendAuthenticationError(f"Client certificate missing for host '{host.id}'")
		if peer_cert_cn != host.id:
			raise BackendAuthenticationError(f"Client certificate CN '{peer_cert_cn}' does not match host id '{host.id}'")
		session.add_auth_methods(AuthenticationMethod.TLS_CERTIFICATE)

	if host.opsiHostKey and session.password == host.opsiHostKey:
		session.add_auth_methods(AuthenticationMethod.HOST_KEY)
		logger.info("Host '%s' authenticated by host key", host.id)
	elif isinstance(host, OpsiClient) and host.oneTimePassword and session.password == host.oneTimePassword:
		session.add_auth_methods(AuthenticationMethod.PASSWORD_ONETIME)
		logger.info("Host '%s' authenticated by onetime password", host.id)
		host.oneTimePassword = ""
		# Update immediately
		await backend.async_call("host_updateObject", host=host)
	else:
		raise BackendAuthenticationError(f"Authentication of host '{host.id}' failed")

	session.host = host
	session.authenticated = True
	session.is_read_only = False
	session.is_admin = host.getType() in ("OpsiConfigserver", "OpsiDepotserver")
	if session.username != host.id:
		session.username = host.id
		if not scope.get("response-headers"):
			scope["response-headers"] = {}
		scope["response-headers"]["x-opsi-new-host-id"] = session.username

	if host.getType() == "OpsiClient":
		logger.info("OpsiClient authenticated, updating host object")
		host.setLastSeen(timestamp())
		if config.update_ip and session.client_addr not in (None, "127.0.0.1", "::1", host.ipAddress):
			host.setIpAddress(session.client_addr)
		else:
			# Value None on update means no change!
			host.ipAddress = None
		await backend.async_call("host_updateObject", host=host)

	elif host.getType() in ("OpsiConfigserver", "OpsiDepotserver"):
		logger.debug("Storing depot server address: %s", session.client_addr)
		depot_addresses[session.client_addr] = time.time()


async def authenticate_user_passwd(scope: Scope) -> None:
	session: OPSISession = scope["session"]
	backend = get_unprotected_backend()
	credentials = await backend.async_call("user_getCredentials", username=session.username)
	if credentials and session.password == credentials.get("password"):
		session.authenticated = True
		session.is_read_only = False
		session.is_admin = False
		session.add_auth_methods(AuthenticationMethod.USERNAME, AuthenticationMethod.PASSWORD_FILE)
	else:
		raise BackendAuthenticationError(f"Authentication failed for user {session.username}")


async def authenticate_user_auth_module(scope: Scope) -> AuthenticationModule:
	session: OPSISession = scope["session"]
	authm = get_auth_module()

	if not authm:
		raise BackendAuthenticationError("Authentication module unavailable")

	peer_cert_cn = get_peer_cert_common_name(scope)

	if "user" in config.client_cert_auth:
		if not peer_cert_cn:
			raise BackendAuthenticationError(f"Client certificate missing for user '{session.username}'")
		if peer_cert_cn != session.username:
			raise BackendAuthenticationError(f"Client certificate CN '{peer_cert_cn}' does not match username '{session.username}'")
		session.add_auth_methods(AuthenticationMethod.TLS_CERTIFICATE)

	logger.debug("Trying to authenticate by user authentication module %s", authm)

	try:
		await run_in_threadpool(authm.authenticate, session.username, session.password or "")
		session.add_auth_methods(AuthenticationMethod.USERNAME, authm.authentication_method)
	except Exception as err:
		raise BackendAuthenticationError(f"Authentication failed for user '{session.username}': {err}") from err

	return authm


async def authenticate(scope: Scope, username: str, password: str, mfa_otp: str | None = None) -> None:
	try:
		await _authenticate(scope, username, password, mfa_otp)
	except BackendAuthenticationError:
		cmd = (
			f"ts.add {config.redis_key('stats')}:client:failed_auth:{ip_address_to_redis_key(scope['client'][0])} "
			f"* 1 RETENTION 86400000 LABELS client_addr {scope['client'][0]}"
		)
		logger.trace(cmd)
		redis = await async_redis_client()
		await redis.execute_command(cmd)  # type: ignore[no-untyped-call]
		await asyncio.sleep(0.2)
		raise


async def _authenticate(scope: Scope, username: str, password: str, mfa_otp: str | None = None) -> None:
	if not scope["session"]:
		addr = scope["client"]
		scope["session"] = await session_manager.get_session(client_addr=addr[0], headers=scope["request_headers"])
	session = scope["session"]
	session.authenticated = False

	await check_min_configed_version(session.user_agent)
	# Check if client address is blocked
	await check_blocked(session.client_addr)

	username = session.username = (username or "").lower()
	password = session.password = password or ""

	logger.info("Start authentication of client %s", session.client_addr)

	if not session.password:
		raise BackendAuthenticationError("No password specified")

	if session.username == config.monitoring_user:
		if config.multi_factor_auth == "totp_mandatory":
			raise BackendAuthenticationError("Monitoring user not available with TOTP mandatory")
		await authenticate_user_passwd(scope=scope)
	elif (
		not session.username
		or session.username.startswith("{hardware_address}")
		or session.username.startswith("{system_uuid}")
		or HOST_ID_RE.search(session.username)
		or HARDWARE_ADDRESS_RE.search(session.username)
		or session.username.count(".") >= 2
	):
		await authenticate_host(scope=scope)
	else:
		if config.multi_factor_auth in ("totp_mandatory", "totp_optional"):
			if not mfa_otp:
				mfa_otp = scope["request_headers"].get("x-opsi-mfa-otp")
			if not mfa_otp:
				match = re.search(r"^(.+)(\d{6})$", session.password)
				if match:
					logger.info("Assuming that TOTP is attached to password")
					session.password = match.group(1)
					secret_filter.add_secrets(session.password)
					mfa_otp = match.group(2)

		auth_module = await authenticate_user_auth_module(scope=scope)
		# Authentication did not throw exception => authentication successful

		backend = get_unprotected_backend()
		if users := await backend.async_call("user_getObjects", id=session.username):
			user = users[0]
		else:
			user = User(id=session.username, created=timestamp())
			await backend.async_call("user_insertObject", user=user)

		if config.multi_factor_auth == "totp_mandatory" or (config.multi_factor_auth == "totp_optional" and user.mfaState == "totp_active"):
			if not user.otpSecret:
				raise BackendAuthenticationError("MFA OTP configuration error")
			if not mfa_otp:
				raise BackendAuthenticationError("MFA one-time password missing")
			totp = pyotp.TOTP(user.otpSecret)
			if not totp.verify(mfa_otp):
				raise BackendAuthenticationError("Incorrect one-time password")
			session.add_auth_methods(AuthenticationMethod.TOTP)
			logger.info("OTP MFA successful")

		session.authenticated = True
		session.user_groups = auth_module.get_groupnames(session.username)
		session.is_admin = auth_module.user_is_admin(session.username)
		session.is_read_only = auth_module.user_is_read_only(session.username)

		logger.info(
			"Authentication successful for user '%s', groups '%s', admin group is '%s', admin: %s, readonly groups %s, readonly: %s",
			session.username,
			",".join(session.user_groups),
			auth_module.get_admin_groupname(),
			session.is_admin,
			auth_module.get_read_only_groupnames(),
			session.is_read_only,
		)

		user.lastLogin = timestamp()
		await backend.async_call("user_updateObject", user=user)

		if session.is_admin:
			create_user_roles(session.username, session.user_groups)

	await session.store(wait=True)

	if not session.username or not session.authenticated:
		raise BackendPermissionDeniedError("Not authenticated")

	logger.debug("Client %s authenticated, username: %s", session.client_addr, session.username)

	await check_admin_networks(session)


async def check_admin_networks(session: OPSISession) -> None:
	if not session.is_admin or not config.admin_networks:
		return

	is_admin_network = False
	for network in config.admin_networks:
		if ip_address_in_network(session.client_addr, network):
			is_admin_network = True
			session.add_auth_methods(AuthenticationMethod.ADMIN_NETWORKS)
			break

	if not is_admin_network:
		logger.warning(
			"User '%s' from '%s' not in admin network '%s'",
			session.username,
			session.client_addr,
			config.admin_networks,
		)
		session.is_admin = False
		admin_group = opsi_config.get("groups", "admingroup")
		if admin_group in session.user_groups:
			# Remove admin group from groups because acl.conf currently does not support is_admin
			session.user_groups.remove(admin_group)


async def check_blocked(ip_address: str) -> None:
	logger.info("Checking if client '%s' is blocked", ip_address)
	redis = await async_redis_client()
	is_blocked = bool(await redis.get(f"{config.redis_key('stats')}:client:blocked:{ip_address_to_redis_key(ip_address)}"))
	if is_blocked:
		logger.info("Client '%s' is blocked", ip_address)
		raise ConnectionRefusedError(f"Client '{ip_address}' is blocked")

	now = int(utc_timestamp() * 1000)
	cmd = (
		f"ts.range {config.redis_key('stats')}:client:failed_auth:{ip_address_to_redis_key(ip_address)} "
		f"{(now-(config.auth_failures_interval*1000))} {now} aggregation count {(config.auth_failures_interval*1000)}"
	)
	logger.debug(cmd)
	try:
		data = await redis.execute_command(cmd)  # type: ignore[no-untyped-call]
		num_failed_auth = int(data[-1][1])
		logger.debug("num_failed_auth: %s", num_failed_auth)
	except RedisResponseError as err:
		num_failed_auth = 0
		if "key does not exist" not in str(err):
			raise
	except IndexError as err:
		logger.debug(err)
		num_failed_auth = 0
	if num_failed_auth >= config.max_auth_failures:
		is_blocked = True
		logger.warning("Blocking client '%s' for %0.2f minutes", ip_address, (config.client_block_time / 60))
		await redis.setex(f"{config.redis_key('stats')}:client:blocked:{ip_address_to_redis_key(ip_address)}", config.client_block_time, 1)


async def check_network(client_addr: str) -> None:
	if not config.networks:
		return
	for network in config.networks:
		if ip_address_in_network(client_addr, network):
			return
	raise ConnectionRefusedError(f"Host '{client_addr}' is not allowed to connect")


async def check_min_configed_version(user_agent: str) -> None:
	if not config.min_configed_version or not user_agent or "opsi config editor" not in user_agent:
		return

	configed_version = None
	try:
		configed_version = Version(user_agent.rsplit()[-1])
	except ValueError as err:
		logger.debug(err)

	if not configed_version or configed_version < config.min_configed_version:
		raise ConnectionRefusedError(
			f"Configed {(str(configed_version) if configed_version else user_agent)} "
			f"is not allowed to connect (min-configed-version: {str(config.min_configed_version)})"
		)


async def check_access(connection: HTTPConnection) -> None:
	scope = connection.scope
	if scope["required_access_role"] == ACCESS_ROLE_PUBLIC:
		return

	session = connection.scope["session"]

	if not session.username or not session.authenticated:
		auth = get_basic_auth(connection.headers)
		await authenticate(connection.scope, auth.username, auth.password)

	if scope["required_access_role"] == ACCESS_ROLE_ADMIN and not session.is_admin:
		raise BackendPermissionDeniedError(f"Not an admin user '{session.username}' {scope.get('method')} {scope.get('path')}")


session_manager = SessionManager()
